<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EasterBunny FPS - WebGPU+WASM</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <!-- gl-matrix for matrix operations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.3/gl-matrix-min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: white;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 24px;
      height: 24px;
      margin: -12px 0 0 -12px;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.7);
      z-index: 10;
      transition: all 0.1s ease;
      display: none;
    }

    #crosshair.target-locked {
      border-color: #ff5555;
      box-shadow: 0 0 12px rgba(255, 0, 0, 0.9);
      transform: scale(1.2);
    }

    #uiContainer {
      position: absolute;
      bottom: 20px;
      left: 240px;
      top: auto;
      width: auto;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      z-index: 5;
      pointer-events: none;
      display: none;
    }

    .ui-panel {
      background: rgba(0, 0, 0, 0.6);
      padding: 12px 20px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform 0.3s ease;
    }

    .ui-panel:hover {
      transform: translateY(-5px);
      background: rgba(0, 0, 0, 0.7);
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 18px;
    }

    .stat .label {
      color: #aaa;
      min-width: 80px;
    }

    .stat .value {
      font-weight: bold;
      min-width: 60px;
    }

    #health .value {
      color: #ff5555;
    }

    #ammo .value {
      color: #55ff55;
    }

    #score .value {
      color: #ffcc00;
    }

    .progress-bar {
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      margin-top: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      transition: width 0.3s ease;
    }

    #healthBar .progress-fill {
      background: linear-gradient(90deg, #ff5555, #ff0000);
    }

    #ammoBar .progress-fill {
      background: linear-gradient(90deg, #55ff55, #00ff00);
    }

    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(20, 20, 40, 0.9) 0%, rgba(10, 10, 30, 0.95) 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 20;
      color: white;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      opacity: 0;
      animation: fadeIn 1s forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #startScreen h1 {
      font-size: 4.5rem;
      margin-bottom: 1.5rem;
      background: linear-gradient(to right, #ff5555, #ffaa00);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      letter-spacing: 2px;
      text-transform: uppercase;
      animation: pulse 2s infinite alternate;
    }

    @keyframes pulse {
      0% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 85, 85, 0.5); }
      50% { transform: scale(1.05); text-shadow: 0 0 20px rgba(255, 85, 85, 0.8); }
      100% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 85, 85, 0.5); }
    }

    #startScreen p {
      font-size: 1.5rem;
      max-width: 700px;
      line-height: 1.6;
      margin-bottom: 2rem;
      color: #ddd;
      animation: slideIn 1s 0.5s forwards;
      opacity: 0;
      transform: translateY(20px);
    }

    @keyframes slideIn {
      to { opacity: 1; transform: translateY(0); }
    }

    #startButton {
      background: linear-gradient(145deg, #4CAF50, #2E8B57);
      border: none;
      color: white;
      padding: 18px 45px;
      font-size: 1.8rem;
      font-weight: bold;
      margin-top: 30px;
      cursor: pointer;
      border-radius: 12px;
      transition: all 0.3s ease;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      letter-spacing: 1px;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      animation: buttonFloat 3s infinite ease-in-out;
    }

    @keyframes buttonFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    #startButton::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.5s;
    }

    #startButton:hover {
      background: linear-gradient(145deg, #45a049, #2d7a4f);
      transform: translateY(-5px) scale(1.05);
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
    }

    #startButton:hover::before {
      left: 100%;
    }

    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(40, 10, 10, 0.9) 0%, rgba(30, 5, 5, 0.95) 100%);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 25;
      color: white;
      opacity: 0;
      animation: fadeIn 1s forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #gameOverScreen h2 {
      font-size: 4rem;
      margin-bottom: 1.5rem;
      color: #ff5555;
      text-transform: uppercase;
      text-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
    }

    #finalScore {
      font-size: 2.5rem;
      margin-bottom: 2rem;
      color: #ffcc00;
      text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
    }

    #restartButton {
      background: linear-gradient(145deg, #4CAF50, #2E8B57);
      border: none;
      color: white;
      padding: 18px 45px;
      font-size: 1.8rem;
      font-weight: bold;
      margin-top: 20px;
      cursor: pointer;
      border-radius: 12px;
      transition: all 0.3s ease;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      letter-spacing: 1px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
    }

    #restartButton::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.5s;
    }

    #restartButton:hover {
      background: linear-gradient(145deg, #45a049, #2d7a4f);
      transform: translateY(-5px);
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
    }

    #restartButton:hover::before {
      left: 100%;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 20px 40px;
      border-radius: 10px;
      font-size: 2rem;
      text-align: center;
      display: none;
      z-index: 15;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
      animation: pulse 2s infinite;
      text-transform: uppercase;
      font-weight: bold;
      letter-spacing: 1px;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
      50% { box-shadow: 0 0 20px rgba(255, 50, 50, 0.8); }
      100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
    }

    .instructions {
      display: none;
    }

    .key {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      padding: 3px 6px;
      border-radius: 6px;
      font-family: monospace;
      font-weight: bold;
      margin: 0 3px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .hit-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.3);
      pointer-events: none;
      opacity: 0;
      z-index: 9;
    }

    .hit-animation {
      animation: hitFlash 0.3s ease;
    }

    @keyframes hitFlash {
      0% { opacity: 0.7; }
      100% { opacity: 0; }
    }

    #nightVisionOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 255, 0, 0.1), rgba(0, 0, 0, 0.8));
      z-index: 4;
      pointer-events: none;
      display: none;
      opacity: 0.7;
      background: rgba(0, 50, 0, 0.7);
      filter: sepia(1) hue-rotate(90deg) saturate(300%) brightness(1.2);
      transition: opacity 0.3s ease, background 0.3s ease, filter 0.3s ease;
    }

    .zombie-counter {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      padding: 10px 20px;
      border-radius: 30px;
      font-size: 1.2rem;
      text-align: center;
      z-index: 5;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 0, 0, 0.5);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
      display: none;
    }

    .zombie-counter span {
      color: #ff5555;
      font-weight: bold;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    @media (max-width: 768px) {
      #startScreen h1 {
        font-size: 2.5rem;
      }

      #startScreen p {
        font-size: 1.1rem;
      }

      .ui-panel {
        padding: 8px 15px;
      }

      .stat {
        font-size: 14px;
      }
    }

    #time-display {
        position: absolute;
        bottom: 20px;
        right: 20px;
        top: auto;
        left: auto;
        z-index: 20;
        text-align: center;
        padding: 15px 25px;
        pointer-events: none;
        background: rgba(10, 25, 47, 0.85);
        border-radius: 16px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(64, 224, 208, 0.3);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        display: none;
    }

    .time {
        font-size: 1.8rem;
        font-weight: bold;
        color: #ffb74d;
        margin-bottom: 5px;
        text-shadow: 0 0 10px rgba(255, 183, 77, 0.5);
    }

    .time-label {
        font-size: 1.1rem;
        color: #ffe0b2;
    }

    #weaponDisplay {
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 20;
        text-align: left;
        padding: 15px 25px;
        pointer-events: none;
        background: rgba(10, 25, 47, 0.85);
        border-radius: 16px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(64, 224, 208, 0.3);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        display: none;
    }

    #weaponName {
        font-size: 1.5rem;
        font-weight: bold;
        color: #00e676;
        margin-bottom: 5px;
    }

    #weaponAmmo {
        font-size: 1.2rem;
        color: #a7ffeb;
    }

    #touchControls {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
        z-index: 100;
        pointer-events: none;
        opacity: 0.4;
    }

    .touch-button {
        position: absolute;
        background: rgba(255, 255, 255, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        width: 100px;
        height: 100px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 35px;
        color: white;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        user-select: none;
        pointer-events: auto;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        transition: background 0.1s ease, transform 0.1s ease;
    }

    .touch-button:active {
        background: rgba(255, 255, 255, 0.5);
        transform: scale(0.95);
    }

    #joystickContainer {
        position: absolute;
        bottom: 15vh;
        left: 8vw;
        width: 187.5px;
        height: 187.5px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: auto;
        touch-action: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    #joystickContainer.sprint-active {
        border-color: rgba(0, 255, 0, 0.6);
        box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    #joystickHandle {
        width: 112.5px;
        height: 112.5px;
        background: rgba(255, 255, 255, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        transform: translate(0, 0);
        transition: transform 0.05s ease-out;
    }

    #shootButton {
        bottom: 15vh;
        right: 8vw;
        width: 130px;
        height: 130px;
        font-size: 45px;
        background: rgba(255, 0, 0, 0.4);
        border-color: rgba(255, 0, 0, 0.6);
    }

    #jumpButton {
        bottom: 30vh;
        right: 8vw;
    }

    #reloadButton {
        bottom: 45vh;
        right: 8vw;
    }

    #nightVisionButton {
        top: 15vh;
        right: 15vw;
        width: 70px;
        height: 70px;
        font-size: 28px;
        border-radius: 10px;
    }

    #switchWeaponButton {
        top: 15vh;
        right: 25vw;
        width: 70px;
        height: 70px;
        font-size: 28px;
        border-radius: 10px;
    }

    .touch-button i {
        font-size: 1.5em;
    }

    #watermark {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.3);
      font-size: 0.8em;
      z-index: 10;
      pointer-events: none;
      display: block;
    }

    #distortionOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 255, 255, 0.1);
      pointer-events: none;
      display: none;
      opacity: 0;
      filter: blur(0px) hue-rotate(0deg) saturate(100%);
      transition: opacity 0.1s ease-out, filter 0.1s ease-out;
      z-index: 99;
    }

    #distortionOverlay.active {
      opacity: 1;
      filter: blur(5px) hue-rotate(180deg) saturate(200%);
    }

    #deloreanDashboard {
        position: absolute;
        bottom: 20px;
        left: 20px;
        top: auto;
        width: auto;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        z-index: 5;
        pointer-events: none;
        display: none;
    }

    .dashboard-panel {
      background: rgba(0, 0, 0, 0.6);
      padding: 12px 20px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform 0.3s ease;
    }

    .dashboard-panel:hover {
      transform: translateY(-5px);
      background: rgba(0, 0, 0, 0.7);
    }

    .dash-stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 18px;
      color: #ddd;
    }

    .dash-stat span {
        font-weight: bold;
        color: #fff;
    }

    #dashSpeed, #dashDistance {
        color: #00ffff;
    }

    #dashFuel {
        color: #ffcc00;
    }

    #dashFuelBar .progress-fill {
        background: linear-gradient(90deg, #ffcc00, #ff8c00);
    }

    #dashHeadlightsStatus {
        color: #ffff00;
    }

    #deloreanWeaponPanel {
        text-align: right;
    }

    #dashWeaponName {
        color: #ff5555;
    }

    #dashWeaponAmmo {
        color: #ffaaaa;
    }

    .atomic-mushroom {
        position: absolute;
        background: radial-gradient(circle at center, rgba(255, 165, 0, 0.8) 0%, rgba(255, 0, 0, 0.5) 50%, transparent 100%);
        border-radius: 50%;
        animation: expandFade 1s forwards;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 999;
    }

    @keyframes expandFade {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
        100% { transform: translate(-50%, -50%) scale(5); opacity: 0; }
    }

    .electric-arc {
        position: absolute;
        background: linear-gradient(to bottom, #00ffff, #0000ff);
        opacity: 0.8;
        animation: electricArcFade 0.5s forwards;
        pointer-events: none;
        z-index: 998;
    }

    @keyframes electricArcFade {
        0% { opacity: 0.8; }
        100% { opacity: 0; }
        }

    #interactionPrompt {
        position: absolute;
        top: 70%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 1.2rem;
        text-align: center;
        display: none;
        z-index: 15;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    #radarCanvas {
        position: absolute;
        bottom: 20px;
        left: 20px;
        border: 2px solid rgba(0, 255, 0, 0.8);
        border-radius: 50%;
        background: rgba(0, 50, 0, 0.7);
        z-index: 10;
        display: none;
    }

    #objectiveDisplay {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: #ffcc00;
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 1.1rem;
        text-align: center;
        z-index: 12;
        display: none;
        box-shadow: 0 0 15px rgba(255, 204, 0, 0.5);
    }

    #craftingMenu {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
        display: none;
        flex-direction: column;
        gap: 20px;
        z-index: 30;
        border: 2px solid rgba(0, 255, 255, 0.5);
    }

    #craftingMenu h3 {
        color: #00ffff;
        font-size: 2rem;
        margin-bottom: 15px;
        text-align: center;
    }

    .crafting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255, 255, 255, 0.1);
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid rgba(0, 255, 255, 0.2);
    }

    .crafting-item span {
        font-size: 1.2rem;
        color: #fff;
    }

    .crafting-button {
        background: linear-gradient(45deg, #00bfff, #0080ff);
        border: none;
        color: white;
        padding: 8px 15px;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.3s ease, transform 0.2s ease;
        font-weight: bold;
    }

    .crafting-button:hover {
        background: linear-gradient(45deg, #009acd, #0066cc);
        transform: translateY(-2px);
    }

    .crafting-button:disabled {
        background: #555;
        cursor: not-allowed;
        opacity: 0.6;
    }

    #closeCrafting {
        background: linear-gradient(45deg, #ff4500, #dc143c);
        border: none;
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.3s ease, transform 0.2s ease;
        font-weight: bold;
        margin-top: 20px;
    }

    #closeCrafting:hover {
        background: linear-gradient(45deg, #cc3700, #a1102f);
        transform: translateY(-2px);
    }

    #resourceDisplay {
        position: absolute;
        bottom: 20px;
        right: 20px;
        top: auto;
        background: rgba(0, 0, 0, 0.6);
        padding: 10px 15px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        display: none;
        color: #fff;
        font-size: 1.1rem;
    }
  </style>
</head>
<body>
  <div id="loadingScreen">
    <h1>CARICAMENTO IN CORSO</h1>
    <p>Ottimizzazione WebGPU + WebAssembly attivata</p>
    <div id="loadingProgress">
      <div id="loadingBar"></div>
    </div>
  </div>

  <div id="crosshair"></div>
  <div class="hit-effect" id="hitEffect"></div>
  <div id="nightVisionOverlay"></div>
  <div id="distortionOverlay"></div>
  <div class="zombie-counter">ZOMBIE: <span id="zombieCount">5</span></div>

  <div id="uiContainer">
    <div class="ui-panel">
      <div class="stat" id="health">
        <div class="label">SALUTE:</div>
        <div class="value">100</div>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="healthBar" style="width: 100%"></div>
      </div>
      <div class="stat" id="ammo">
        <div class="label">MUNIZIONI:</div>
        <div class="value">30/30</div>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="ammoBar" style="width: 100%"></div>
      </div>
    </div>

    <div class="ui-panel">
      <div class="stat" id="score">
        <div class="label">PUNTEGGIO:</div>
        <div class="value">0</div>
      </div>
      <div class="stat">
        <div class="label">ONDA:</div>
        <div class="value">1</div>
      </div>
    </div>
  </div>

  <div id="message"></div>

  <div class="instructions">
    <p>MOVIMENTO: <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> | SALTO: <span class="key">SPAZIO</span> | SCATTO: <span class="key">SHIFT</span></p>
    <p id="deloreanInstructions" style="display:none;">ENTRA/ESCI: <span class="key">E</span> | FARI: <span class="key">L</span> | SPARA MITRAGLIATRICE: <span class="key">F</span> | SPARA CANNONE: <span class="key">G</span></p>
    <p>CRAFTING: <span class="key">C</span></p>
  </div>

  <div id="startScreen">
    <h1>EASTERBUNNY</h1>
    <p>Kael è atterrato su un pianeta sconosciuto, infestato da creature. La tua missione è sopravvivere e scoprire i segreti di questo luogo.</p>
    <button id="startButton">INIZIA MISSIONE</button>
  </div>

  <div id="gameOverScreen">
    <h2>MISSIONE FALLITA</h2>
    <p id="finalScore">Punto Finale: 0</p>
    <p>Le creature hanno invaso la tua posizione...</p>
    <button id="restartButton">RIAVVIA MISSIONE</button>
  </div>

  <div id="time-display">
    <div class="time">12:00 PM</div>
    <div class="time-label">GIORNO SOLEGGIATO</div>
  </div>

  <div id="weaponDisplay">
    <div id="weaponName">FUCILE</div>
    <div id="weaponAmmo">30/30</div>
  </div>

  <div id="deloreanDashboard">
    <div class="dashboard-panel">
        <div class="dash-stat">Velocità: <span id="dashSpeed">0 km/h</span></div>
        <div class="dash-stat">Distanza: <span id="dashDistance">0 km</span></div>
        <div class="dash-stat">Benzina: <span id="dashFuel">100%</span></div>
        <div class="progress-bar"><div class="progress-fill" id="dashFuelBar" style="width: 100%"></div></div>
        <div class="dash-stat">Fari: <span id="dashHeadlightsStatus">SPENTI</span></div>
    </div>
    <div id="deloreanWeaponPanel" class="dashboard-panel">
        <div class="dash-stat">Arma: <span id="dashWeaponName">MITRAGLIATRICE</span></div>
        <div class="dash-stat">Munizioni: <span id="dashWeaponAmmo">500/500</span></div>
    </div>
  </div>

  <div id="touchControls">
    <div id="joystickContainer">
      <div id="joystickHandle"></div>
    </div>

    <div id="jumpButton" class="touch-button">
        <i class="fas fa-arrow-up"></i>
    </div>
    <div id="shootButton" class="touch-button">
        <i class="fas fa-crosshairs"></i>
    </div>
    <div id="reloadButton" class="touch-button">
        <i class="fas fa-sync-alt"></i>
    </div>
    <div id="nightVisionButton" class="touch-button">
        <i class="fas fa-moon"></i>
    </div>
    <div id="switchWeaponButton" class="touch-button">
        <i class="fas fa-exchange-alt"></i>
    </div>
    <div id="enterExitDeLoreanButton" class="touch-button" style="bottom: 15vh; left: 25vw; display: none;">
        <i class="fas fa-car"></i>
    </div>
    <div id="headlightsButton" class="touch-button" style="top: 15vh; left: 8vw; display: none;">
        <i class="fas fa-lightbulb"></i>
    </div>
    <div id="deloreanMachineGunButton" class="touch-button" style="bottom: 30vh; right: 20vw; display: none;">
        <i class="fas fa-gun"></i>
    </div>
    <div id="deloreanCannonButton" class="touch-button" style="bottom: 45vh; right: 20vw; display: none;">
        <i class="fas fa-bomb"></i>
    </div>
    <div id="craftingButton" class="touch-button" style="top: 15vh; left: 25vw; width: 70px; height: 70px; font-size: 28px; border-radius: 10px; display: none;">
        <i class="fas fa-hammer"></i>
    </div>
  </div>

  <div id="watermark">Tutti i diritti riservati © 2025 Ernesto Lamberti</div>

  <div id="interactionPrompt">Premi E per salire sulla DeLorean</div>

  <canvas id="radarCanvas"></canvas>

  <div id="objectiveDisplay"></div>

  <div id="craftingMenu">
    <h3>CRAFTING</h3>
    <div class="crafting-item">
        <span>Munizioni Fucile (x30)</span>
        <span>Costo: 5 Risorse</span>
        <button class="crafting-button" id="craftRifleAmmo">Crafta</button>
    </div>
    <div class="crafting-item">
        <span>Munizioni Fucile a Pompa (x8)</span>
        <span>Costo: 8 Risorse</span>
        <button class="crafting-button" id="craftShotgunAmmo">Crafta</button>
    </div>
    <button id="closeCrafting">Chiudi</button>
  </div>

  <div id="resourceDisplay">Risorse: <span id="resourceCount">0</span></div>

  <!-- Stats.js for performance monitoring -->
  <script src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>
  <script>
    // Define global variables and constants
    const movement = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        sprint: false,
        playerSpeed: 5, // Base player speed
        joystickActive: false,
        joystickStart: { x: 0, y: 0 },
        joystickRadius: 75, // Half of joystickContainer width/height divided by 2
        joystickSprintThresholdRatio: 0.7 // 70% of radius to activate sprint
    };

    let currentTime = 12; // Initial time of day (12 PM)
    let stats; // Stats.js instance
    let radarCanvas;
    let radarCtx;
    const radarSize = 200; // Size of the radar canvas
    let isTouchDevice = false;

    // UI elements
    const crosshair = document.getElementById('crosshair');
    const timeDisplayCard = document.getElementById('time-display');
    const timeDisplayTime = timeDisplayCard.querySelector('.time');
    const timeDisplayLabel = timeDisplayCard.querySelector('.time-label');
    const weaponDisplay = document.getElementById('weaponDisplay');
    const weaponName = document.getElementById('weaponName');
    const weaponAmmo = document.getElementById('weaponAmmo');
    const deloreanDashboard = document.getElementById('deloreanDashboard');
    const dashSpeed = document.getElementById('dashSpeed');
    const dashDistance = document.getElementById('dashDistance');
    const dashFuel = document.getElementById('dashFuel');
    const dashFuelBar = document.getElementById('dashFuelBar');
    const dashHeadlightsStatus = document.getElementById('dashHeadlightsStatus');
    const dashWeaponName = document.getElementById('dashWeaponName');
    const dashWeaponAmmo = document.getElementById('dashWeaponAmmo');
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickHandle = document.getElementById('joystickHandle');
    const jumpButton = document.getElementById('jumpButton');
    const shootButton = document.getElementById('shootButton');
    const reloadButton = document.getElementById('reloadButton');
    const nightVisionButton = document.getElementById('nightVisionButton');
    const switchWeaponButton = document.getElementById('switchWeaponButton');
    const enterExitDeLoreanButton = document.getElementById('enterExitDeLoreanButton');
    const headlightsButton = document.getElementById('headlightsButton');
    const deloreanMachineGunButton = document.getElementById('deloreanMachineGunButton');
    const deloreanCannonButton = document.getElementById('deloreanCannonButton');
    const craftingButton = document.getElementById('craftingButton');
    const interactionPrompt = document.getElementById('interactionPrompt');
    const objectiveDisplay = document.getElementById('objectiveDisplay');
    const craftingMenu = document.getElementById('craftingMenu');
    const closeCraftingButton = document.getElementById('closeCrafting');
    const craftRifleAmmoButton = document.getElementById('craftRifleAmmo');
    const craftShotgunAmmoButton = document.getElementById('craftShotgunAmmo');
    const nightVisionOverlay = document.getElementById('nightVisionOverlay');
    const distortionOverlay = document.getElementById('distortionOverlay');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const restartButton = document.getElementById('restartButton');
    const message = document.getElementById('message');
    const hitEffect = document.getElementById('hitEffect');
    const healthBar = document.getElementById('healthBar');
    const ammoBar = document.getElementById('ammoBar');
    const zombieCount = document.getElementById('zombieCount');
    const resourceDisplay = document.getElementById('resourceDisplay');

    // Player and DeLorean positions (conceptual)
    // Initialize transform as empty objects, will be populated with glMatrix.mat4.create() later
    const playerPosition = { x: 0, y: 1.6, z: 0, transform: {} };
    const deloreanPosition = { x: -80, y: 2.5, z: 80 };

    // Keyboard state
    const keys = {};

    // Game State (comprehensive)
    const gameState = {
        playerHealth: 100,
        maxHealth: 100,
        score: 0,
        level: 1,
        zombiesDestroyed: 0,
        zombiesTotal: 5,
        zombies: [],
        projectiles: [], // Now will be managed with pooling
        powerUps: [],
        destructibleRocks: [],
        maxDestructibleRocks: 5,

        isReloading: false,
        gameOver: false,
        nightVision: false,
        isShooting: false,
        lastShotPosition: { x: 0, y: 0, z: 0 }, // For effects
        isDamageBoostActive: false,
        damageBoostDuration: 10, // seconds
        damageBoostTimer: 0,
        damageBoostMultiplier: 2,
        isSpeedBoostActive: false,
        speedBoostDuration: 10, // seconds
        speedBoostTimer: 0,
        speedBoostMultiplier: 1.5,
        isDistorted: false,
        distortionTimer: 0,

        isCloudStormActive: false,
        cloudStormTimer: 0,
        cloudStormLightningTimer: 0,
        triggeredRainDuration: 60, // seconds
        atmosphericExplosionDuration: 5, // seconds

        resources: 0,
        isCraftingMenuOpen: false,

        gameDay: 1,
        lastWeatherChangeDay: 0,
        currentWeather: 'clear',
        weatherTimer: 0, // Duration of current weather effect
        lightningFlickerTimer: 0,
        isLightningActive: false,
        lightningInterval: 0.5, // seconds between lightning flashes
        lightningDuration: 0.1, // duration of lightning flash

        lightningZombieExists: false,
        lightningStrikeRandomIntervalMin: 10, // seconds
        lightningStrikeRandomIntervalMax: 30, // seconds
        lightningStrikeRandomTimer: 0,

        weapons: {
            rifle: {
                name: "FUCILE",
                ammo: 30,
                clipSize: 30,
                maxAmmo: 90,
                damage: 10,
                fireRate: 0.2, // seconds between shots
                lastShotTime: 0,
                isShooting: false
            },
            shotgun: {
                name: "FUCILE A POMPA",
                ammo: 8,
                clipSize: 8,
                maxAmmo: 24,
                damage: 25,
                fireRate: 0.8,
                lastShotTime: 0,
                isShooting: false,
                pellets: 5,
                spreadAngle: 0.5
            }
        },
        currentWeapon: 'rifle',

        inDeLorean: false,
        delorean: {
            transform: {} // Initialize transform as empty object
        },
        deloreanFuel: 100,
        maxDeLoreanFuel: 100,
        deloreanDistanceTraveled: 0,
        deloreanKmPerUnit: 0.01, // 1 unit = 0.01 km
        deloreanIsVulnerable: false, // If fuel is 0, DeLorean becomes vulnerable
        deloreanVulnerabilityDuration: 10, // seconds
        deloreanVulnerabilityTimer: 0,

        deloreanWeapons: {
            machineGun: {
                name: "MITRAGLIATRICE",
                ammo: 500,
                maxAmmo: 500,
                damage: 5,
                fireRate: 0.05,
                lastShotTime: 0,
                isShooting: false,
                muzzleFlashLight: false
            },
            cannon: {
                name: "CANNONE",
                ammo: 10,
                maxAmmo: 10,
                damage: 100,
                fireRate: 2,
                lastShotTime: 0,
                isShooting: false,
                aoeRadius: 10
            }
        },
        currentDeLoreanWeapon: 'machineGun',
        deloreanPlayer: { // Simplified DeLorean movement state
            speed: 0,
            rotation: 0,
            nitro: 100,
            isDrifting: false,
            driftTime: 0
        },

        powerUpSpawnInterval: 15, // seconds
        powerUpSpawnTimer: 0,

        rockSpawnInterval: 10, // seconds
        rockSpawnTimer: 0,

        currentObjective: null, // e.g., 'activate_lighthouse', 'collect_resources'
        objectiveTimer: 0,
        objectiveDuration: 60, // seconds
        objectiveTargetCount: 0,
        objectiveCurrentCount: 0,

        lighthouseMesh: null, // { position: {x,y,z}, isActive: boolean }
    };

    // MAX_ZOMBIES and MAX_PROJECTILES for WASM buffer sizing
    const MAX_ZOMBIES = 100;
    const MAX_PROJECTILES = 200; // Max concurrent projectiles

    // Pre-allocate glMatrix objects to reduce garbage collection.
    // These are temporary matrices and vectors used in calculations to avoid frequent memory allocations.
    // Declared globally, initialized later in initGame to ensure glMatrix is loaded.
    let tempMat4; // A 4x4 matrix for general transformations (e.g., model, MVP)
    let tempMat3; // A 3x3 matrix for normal transformations
    let tempVec3_1; // A 3-element vector for general vector operations
    let tempVec3_2; // Another 3-element vector for general vector operations

    // PhysicsSystem class (from user's conceptual code)
    class PhysicsSystem {
        constructor() {
            // No WASM module loading directly here; will use JS fallback
            this.ready = false; // Will be set to true in init
            this.gravity = 9.8;
            this.worldBounds = [-500, 500, -500, 500]; // [minX, maxX, minZ, maxZ]
        }

        async init() {
            // Simulate WASM initialization success but use JS fallback
            console.warn("WASM physics module is conceptual. Using JavaScript fallback for physics simulation.");
            this.ready = true;
        }

        // Update physics simulation - always uses JS fallback in this version
        update(deltaTime, playerPos, inVehicle, vehiclePos) {
            this.updateJSFallback(deltaTime, playerPos, inVehicle, vehiclePos);
        }

        // Fallback implementation in JavaScript if WASM fails
        updateJSFallback(deltaTime, playerPos, inVehicle, vehiclePos) {
            // Zombie AI
            gameState.zombies.forEach(zombie => {
                if (zombie.health <= 0) return; // Skip dead zombies

                const targetX = inVehicle ? vehiclePos.x : playerPos.x;
                const targetZ = inVehicle ? vehiclePos.z : playerPos.z;

                const dx = targetX - zombie.x;
                const dz = targetZ - zombie.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                if (dist > 0.1) {
                    let speed = zombie.originalSpeed; // Use originalSpeed from JS state
                    if (zombie.isLightningZombie) speed *= 2.5;
                    if (zombie.isKamikazeBunny) speed = 4.0;
                    speed *= deltaTime;

                    zombie.vx = (dx / dist) * speed;
                    zombie.vz = (dz / dist) * speed;
                } else {
                    zombie.vx = 0;
                    zombie.vz = 0;
                }

                // Apply gravity (conceptual, not full physics)
                zombie.vy -= this.gravity * deltaTime; // Use gravity from physWorld

                zombie.x += zombie.vx;
                zombie.y += zombie.vy;
                zombie.z += zombie.vz;

                // World bounds
                zombie.x = Math.max(this.worldBounds[0], Math.min(this.worldBounds[1], zombie.x));
                zombie.z = Math.max(this.worldBounds[2], Math.min(this.worldBounds[3], zombie.z));
                zombie.y = Math.max(0.75, zombie.y); // Keep above ground
            });


            // Projectile movement (using pooling)
            gameState.projectiles.forEach(p => {
                if (!p.active) return; // Skip inactive projectiles

                p.x += p.dx * p.speed * deltaTime;
                p.y += p.dy * p.speed * deltaTime;
                p.z += p.dz * p.speed * deltaTime;

                // Deactivate if out of bounds
                if (p.y < -10 ||
                    p.x < this.worldBounds[0] - 100 || p.x > this.worldBounds[1] + 100 ||
                    p.z < this.worldBounds[2] - 100 || p.z > this.worldBounds[3] + 100) {
                    p.active = false;
                }
            });
        }

        // Method to add a zombie (directly to JS state for fallback)
        addZombie(jsZombieData) {
            gameState.zombies.push(jsZombieData);
        }

        // Method to get an inactive projectile from the pool or create a new one
        getProjectile() {
            let projectile = gameState.projectiles.find(p => !p.active);
            if (!projectile) {
                projectile = { active: false }; // Create a new one if pool is empty
                gameState.projectiles.push(projectile);
            }
            projectile.active = true;
            return projectile;
        }
    }

    // Initialize the physics system globally
    const physicsSystem = new PhysicsSystem();

    // WGSL Shaders
    const opaqueWGSL = `
        // VertexInput struct defines the per-vertex attributes (position, normal, UV)
        struct VertexInput {
            @location(0) position: vec3<f32>,
            @location(1) normal: vec3<f32>,
            @location(2) uv: vec2<f32>
        };

        // VertexOutput struct defines the data passed from the vertex shader to the fragment shader
        struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) normal: vec3<f32>,
            @location(1) uv: vec2<f32>,
            @location(2) world_pos: vec3<f32>,
            @location(3) instance_material_id: u32
        };

        // Group 0: Global uniforms (camera MVP, texture, sampler)
        @group(0) @binding(0) var<uniform> mvp: mat4x4<f32>; // Combined View-Projection matrix
        @group(0) @binding(1) var texture: texture_2d<f32>;
        @group(0) @binding(2) var tex_sampler: sampler;

        // Group 1: Material parameters (array of structs)
        struct MaterialParams {
            baseColor: vec4f,
            roughness: f32,
            metallic: f32,
            specular: f32,
            _padding: f32 // Padding to align to 16 bytes (vec4f is 16 bytes, f32 is 4 bytes, total 32 bytes)
        };
        @group(1) @binding(0) var<uniform> materialArray: array<MaterialParams>;

        // Group 2: Lighting uniforms
        @group(2) @binding(0) var<uniform> lightDirection: vec3<f32>;
        @group(2) @binding(1) var<uniform> ambientColor: vec3<f32>;


        @vertex
        fn vs_main(
            input: VertexInput, // Per-vertex data from buffer 0 (locations 0, 1, 2)
            // Per-instance data from buffer 1 (locations 4-11)
            @location(4) instance_model_matrix_row0: vec4<f32>,
            @location(5) instance_model_matrix_row1: vec4<f32>,
            @location(6) instance_model_matrix_row2: vec4<f32>,
            @location(7) instance_model_matrix_row3: vec4<f32>,
            @location(8) instance_normal_matrix_row0: vec3<f32>,
            @location(9) instance_normal_matrix_row1: vec3<f32>,
            @location(10) instance_normal_matrix_row2: vec3<f32>,
            @location(11) instance_material_id: u32
        ) -> VertexOutput {
            var output: VertexOutput;

            // Reconstruct model matrix from rows
            let instance_model_matrix = mat4x4<f32>(
                instance_model_matrix_row0,
                instance_model_matrix_row1,
                instance_model_matrix_row2,
                instance_model_matrix_row3
            );

            // Reconstruct normal matrix from rows
            let instance_normal_matrix = mat3x3<f32>(
                instance_normal_matrix_row0,
                instance_normal_matrix_row1,
                instance_normal_matrix_row2
            );

            // Apply instance transformation to position
            let transformed_position = instance_model_matrix * vec4<f32>(input.position, 1.0);
            output.position = mvp * transformed_position; // Apply view-projection matrix

            // Transform normal by instance normal matrix
            output.normal = instance_normal_matrix * input.normal;
            output.uv = input.uv;
            output.world_pos = transformed_position.xyz; // World position after instance transform
            output.instance_material_id = instance_material_id; // Pass material ID to fragment shader
            return output;
        }

        @fragment
        fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
            let material = materialArray[input.instance_material_id]; // Get material from array
            let base_color_texture = textureSample(texture, tex_sampler, input.uv);
            let base_color = base_color_texture * material.baseColor; // Apply base color from material
            let normal = normalize(input.normal);

            // Illuminazione diffusa
            let diff = max(dot(normal, normalize(lightDirection)), 0.0);
            let final_color_rgb = base_color.rgb * (ambientColor + diff * 0.9) * (1.0 - material.roughness) + material.specular;

            return vec4<f32>(final_color_rgb, base_color.a);
        }
    `;

    const transparentWGSL = `
        // VertexInput struct defines the per-vertex attributes (position, normal, UV)
        struct VertexInput {
            @location(0) position: vec3<f32>,
            @location(1) normal: vec3<f32>,
            @location(2) uv: vec2<f32>
        };

        // VertexOutput struct defines the data passed from the vertex shader to the fragment shader
        struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) normal: vec3<f32>,
            @location(1) uv: vec2<f32>,
            @location(2) world_pos: vec3<f32>,
            @location(3) instance_material_id: u32
        };

        // Group 0: Global uniforms (camera MVP, texture, sampler)
        @group(0) @binding(0) var<uniform> mvp: mat4x4<f32>; // Combined View-Projection matrix
        @group(0) @binding(1) var texture: texture_2d<f32>;
        @group(0) @binding(2) var tex_sampler: sampler;

        // Group 1: Material parameters (array of structs)
        struct MaterialParams {
            baseColor: vec4f,
            roughness: f32,
            metallic: f32,
            specular: f32,
            _padding: f32
        };
        @group(1) @binding(0) var<uniform> materialArray: array<MaterialParams>;

        @vertex
        fn vs_main(
            input: VertexInput, // Per-vertex data from buffer 0 (locations 0, 1, 2)
            // Per-instance data from buffer 1 (locations 4-11)
            @location(4) instance_model_matrix_row0: vec4<f32>,
            @location(5) instance_model_matrix_row1: vec4<f32>,
            @location(6) instance_model_matrix_row2: vec4<f32>,
            @location(7) instance_model_matrix_row3: vec4<f32>,
            @location(8) instance_normal_matrix_row0: vec3<f32>,
            @location(9) instance_normal_matrix_row1: vec3<f32>,
            @location(10) instance_normal_matrix_row2: vec3<f32>,
            @location(11) instance_material_id: u32
        ) -> VertexOutput {
            var output: VertexOutput;

            // Reconstruct model matrix from rows
            let instance_model_matrix = mat4x4<f32>(
                instance_model_matrix_row0,
                instance_model_matrix_row1,
                instance_model_matrix_row2,
                instance_model_matrix_row3
            );

            // Reconstruct normal matrix from rows
            let instance_normal_matrix = mat3x3<f32>(
                instance_normal_matrix_row0,
                instance_normal_matrix_row1,
                instance_normal_matrix_row2
            );

            // Apply instance transformation to position
            let transformed_position = instance_model_matrix * vec4<f32>(input.position, 1.0);
            output.position = mvp * transformed_position; // Apply view-projection matrix

            // Transform normal by instance normal matrix
            output.normal = instance_normal_matrix * input.normal;
            output.uv = input.uv;
            output.world_pos = transformed_position.xyz; // World position after instance transform
            output.instance_material_id = instance_material_id; // Pass material ID to fragment shader
            return output;
        }

        @fragment
        fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
            let material = materialArray[input.instance_material_id]; // Get material from array
            let base_color_texture = textureSample(texture, tex_sampler, input.uv);
            let base_color = base_color_texture * material.baseColor; // Apply base color from material
            // Simple transparency
            return vec4<f32>(base_color.rgb, base_color.a * 0.5); // 50% transparent
        }
    `;

    const effectsWGSL = `
        struct VertexInput {
            @location(0) position: vec3<f32>,
            @location(1) color: vec3<f32>
        };

        struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) color: vec3<f32>
        };

        @group(0) @binding(0) var<uniform> mvp: mat4x4<f32>;

        @vertex
        fn vs_main(input: VertexInput) -> VertexOutput {
            var output: VertexOutput;
            output.position = mvp * vec4<f32>(input.position, 1.0);
            output.color = input.color;
            return output;
        }

        @fragment
        fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
            return vec4<f32>(input.color, 1.0);
        }
    `;

    const deloreanWGSL = `
        // VertexInput struct defines the per-vertex attributes (position, normal, UV)
        struct VertexInput {
            @location(0) position: vec3<f32>,
            @location(1) normal: vec3<f32>,
            @location(2) uv: vec2<f32>
        };

        // VertexOutput struct defines the data passed from the vertex shader to the fragment shader
        struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) normal: vec3<f32>,
            @location(1) uv: vec2<f32>,
            @location(2) world_pos: vec3<f32>,
            @location(3) instance_material_id: u32
        };

        // Group 0: Global uniforms (camera MVP, texture, sampler, time)
        @group(0) @binding(0) var<uniform> mvp: mat4x4<f32>; // Combined View-Projection matrix
        @group(0) @binding(1) var texture: texture_2d<f32>;
        @group(0) @binding(2) var tex_sampler: sampler;
        @group(0) @binding(3) var<uniform> time: f32; // For special effects

        // Group 1: Material parameters (array of structs) and special DeLorean effects
        struct MaterialParams {
            baseColor: vec4f,
            roughness: f32,
            metallic: f32,
            specular: f32,
            _padding: f32
        };
        @group(1) @binding(0) var<uniform> materialArray: array<MaterialParams>;
        @group(1) @binding(1) var<uniform> cameraPos: vec3<f32>; // Camera position for reflection
        @group(1) @binding(2) var reflectionMap: texture_cube<f32>; // Cube map for reflections
        @group(1) @binding(3) var reflectionSampler: sampler;
        @group(1) @binding(4) var emissionMap: texture_2d<f32>; // Emission texture
        @group(1) @binding(5) var<uniform> emissionStrength: f32;


        // Group 2: Lighting uniforms
        @group(2) @binding(0) var<uniform> lightDirection: vec3<f32>;
        @group(2) @binding(1) var<uniform> ambientColor: vec3<f32>;

        // Function to calculate reflection UVs (conceptual)
        fn calculateReflectionUV(world_pos: vec3<f32>, camera_pos: vec3<f32>, normal: vec3<f32>) -> vec3<f32> {
            let view_dir = normalize(camera_pos - world_pos);
            let reflect_dir = reflect(view_dir, normal);
            return reflect_dir;
        }

        @vertex
        fn vs_main(
            input: VertexInput, // Per-vertex data from buffer 0 (locations 0, 1, 2)
            // Per-instance data from buffer 1 (locations 4-11)
            @location(4) instance_model_matrix_row0: vec4<f32>,
            @location(5) instance_model_matrix_row1: vec4<f32>,
            @location(6) instance_model_matrix_row2: vec4<f32>,
            @location(7) instance_model_matrix_row3: vec4<f32>,
            @location(8) instance_normal_matrix_row0: vec3<f32>,
            @location(9) instance_normal_matrix_row1: vec3<f32>,
            @location(10) instance_normal_matrix_row2: vec3<f32>,
            @location(11) instance_material_id: u32
        ) -> VertexOutput {
            var output: VertexOutput;

            // Reconstruct model matrix from rows
            let instance_model_matrix = mat4x4<f32>(
                instance_model_matrix_row0,
                instance_model_matrix_row1,
                instance_model_matrix_row2,
                instance_model_matrix_row3
            );

            // Reconstruct normal matrix from rows
            let instance_normal_matrix = mat3x3<f32>(
                instance_normal_matrix_row0,
                instance_normal_matrix_row1,
                instance_normal_matrix_row2
            );

            // Apply instance transformation to position
            let transformed_position = instance_model_matrix * vec4<f32>(input.position, 1.0);
            output.position = mvp * transformed_position; // Apply view-projection matrix

            // Transform normal by instance normal matrix
            output.normal = instance_normal_matrix * input.normal;
            output.uv = input.uv;
            output.world_pos = transformed_position.xyz; // World position after instance transform
            output.instance_material_id = instance_material_id; // Pass material ID to fragment shader
            return output;
        }

        @fragment
        fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
            let material = materialArray[input.instance_material_id]; // Get material from array
            let base_color_texture = textureSample(texture, tex_sampler, input.uv);
            let base_color = base_color_texture * material.baseColor; // Apply base color from material
            let normal = normalize(input.normal);

            // Basic lighting
            let diff = max(dot(normal, normalize(lightDirection)), 0.0);
            let ambient = ambientColor;

            // Effetto emissione (e.g., for reactor glow, headlights)
            let emission_color = textureSample(emissionMap, tex_sampler, input.uv).rgb * emissionStrength;

            // Effetto riflessione
            let reflect_dir = calculateReflectionUV(input.world_pos, cameraPos, normal);
            let reflection_color = textureSample(reflectionMap, reflectionSampler, reflect_dir).rgb;

            // Simple time-based distortion for reactor (conceptual)
            let distortion_factor = sin(time * 10.0) * 0.05;
            let distorted_uv = input.uv + vec2<f32>(distortion_factor, distortion_factor);
            let distorted_color_sample = textureSample(texture, tex_sampler, distorted_uv);

            // Mix base color, reflection, and emission
            let final_color_rgb = mix(base_color.rgb * (ambient + diff * 0.9), reflection_color, material.metallic) + emission_color; // Use material.metallic

            // Apply thermal distortion to parts of the car (conceptual, based on UV or world_pos)
            // For a real implementation, you'd need a mask texture or specific UV ranges
            let thermal_distortion_mask = step(0.8, input.uv.y); // Example: apply distortion to top part of the texture
            let final_color_with_distortion = mix(final_color_rgb, distorted_color_sample.rgb, thermal_distortion_mask);


            return vec4<f32>(final_color_with_distortion, base_color.a);
        }
    `;

    const skyWGSL = `
        struct VertexInput {
            @location(0) position: vec3<f32>
        };

        struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) world_pos: vec3<f32>
        };

        @group(0) @binding(0) var<uniform> view_projection: mat4x4<f32>;

        @vertex
        fn vs_main(input: VertexInput) -> VertexOutput {
            var output: VertexOutput;
            // Set Z to W for skybox to ensure it's always at max depth
            output.position = view_projection * vec4<f32>(input.position, 1.0);
            output.position.z = output.position.w;
            output.world_pos = input.position;
            return output;
        }

        @fragment
        fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
            // Simple gradient skybox
            let normalized_y = (input.world_pos.y + 1.0) / 2.0; // Normalize y from -1 to 1 to 0 to 1
            let sky_color_top = vec3<f32>(0.2, 0.5, 0.8); // Blue
            let sky_color_bottom = vec3<f32>(0.8, 0.9, 1.0); // Light blue/white
            let final_color = mix(sky_color_bottom, sky_color_top, normalized_y);
            return vec4<f32>(final_color, 1.0);
        }
    `;

    const postProcessWGSL = `
        struct VertexOutput {
            @builtin(position) position: vec4f,
            @location(0) uv: vec2f,
        };

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var out: VertexOutput;
            let uv = vec2f(f32(vertexIndex & 1u), f32(vertexIndex >> 1u));
            out.position = vec4f(uv * 2.0 - 1.0, 0.0, 1.0);
            out.uv = uv;
            return out;
        }

        @group(0) @binding(0) var inputTexture: texture_2d<f32>;
        @group(0) @binding(1) var inputSampler: sampler;
        @group(0) @binding(2) var<uniform> resolution: vec2f;
        @group(0) @binding(3) var<uniform> time: f32; // For simple effects

        @fragment
        fn fs_main(input: VertexOutput) -> @location(0) vec4f {
            let color = textureSample(inputTexture, inputSampler, input.uv);

            // Simple bloom effect (conceptual - would involve multiple passes)
            // For demonstration, a slight glow based on brightness
            let brightness = dot(color.rgb, vec3f(0.2126, 0.7152, 0.0722));
            let bloom_threshold = 0.8;
            let bloom_intensity = 1.5;
            let bloom = max(vec3f(0.0), color.rgb - bloom_threshold) * bloom_intensity;

            // Simple chromatic aberration (conceptual)
            let offset = vec2f(sin(time * 5.0) * 0.005, cos(time * 7.0) * 0.005);
            let r_color = textureSample(inputTexture, inputSampler, input.uv + offset).r;
            let g_color = textureSample(inputTexture, inputSampler, input.uv).g;
            let b_color = textureSample(inputTexture, inputSampler, input.uv - offset).b;

            let final_color = vec3f(r_color, g_color, b_color) + bloom;

            // Simple tonemapping (Reinhard)
            let tonemapped_color = final_color / (final_color + vec3f(1.0));

            return vec4f(tonemapped_color, color.a);
        }
    `;

    const particleComputeShaderWGSL = `
        struct Particle {
            position: vec3f,
            velocity: vec3f,
            color: vec4f,
            lifetime: f32
        };

        @group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
        @group(0) @binding(1) var<uniform> deltaTime: f32;

        @compute @workgroup_size(64)
        fn simulateParticles(@builtin(global_invocation_id) id: vec3u) {
            let idx = id.x;
            if (idx >= arrayLength(&particles)) { return; }

            var particle = particles[idx];

            // Aggiorna fisica
            particle.velocity.y -= 9.8 * deltaTime; // Apply gravity
            particle.position += particle.velocity * deltaTime;
            particle.lifetime -= deltaTime;

            // Ricicla le particelle morte (semplice reset)
            if (particle.lifetime <= 0.0) {
                particle.position = vec3f(0.0, 5.0, 0.0); // Reset to a spawn point
                particle.velocity = vec3f((f32(id.x % 10) - 5.0) * 0.1, 1.0 + f32(id.y % 5) * 0.2, (f32(id.z % 10) - 5.0) * 0.1); // New random velocity
                particle.lifetime = 5.0; // New lifetime
                particle.color = vec4f(fract(f32(id.x) * 0.1), fract(f32(id.y) * 0.1), fract(f32(id.z) * 0.1), 1.0); // New random color
            }

            particles[idx] = particle;
        }
    `;

    // Mock GLTF Loader (conceptual)
    async function loadGLTFModel(url) {
        console.log(`Mock loading GLTF model from: ${url}`);
        // Simulate loading a simple cube or bunny geometry
        const vertices = new Float32Array([
            // positions (x,y,z), normals (nx,ny,nz), uvs (u,v)
            // Front face
            -1.0, -1.0,  1.0,  0.0, 0.0, 1.0,  0.0, 0.0,
             1.0, -1.0,  1.0,  0.0, 0.0, 1.0,  1.0, 0.0,
             1.0,  1.0,  1.0,  0.0, 0.0, 1.0,  1.0, 1.0,
            -1.0,  1.0,  1.0,  0.0, 0.0, 1.0,  0.0, 1.0,

            // Back face
            -1.0, -1.0, -1.0,  0.0, 0.0, -1.0, 1.0, 0.0,
             1.0, -1.0, -1.0,  0.0, 0.0, -1.0, 0.0, 0.0,
             1.0,  1.0, -1.0,  0.0, 0.0, -1.0, 0.0, 1.0,
            -1.0,  1.0, -1.0,  0.0, 0.0, -1.0, 1.0, 1.0,

            // Top face
            -1.0,  1.0, -1.0,  0.0, 1.0, 0.0,  0.0, 1.0,
             1.0,  1.0, -1.0,  0.0, 1.0, 0.0,  1.0, 1.0,
             1.0,  1.0,  1.0,  0.0, 1.0, 0.0,  1.0, 0.0,
            -1.0,  1.0,  1.0,  0.0, 1.0, 0.0,  0.0, 0.0,

            // Bottom face
            -1.0, -1.0, -1.0,  0.0, -1.0, 0.0, 0.0, 1.0,
             1.0, -1.0, -1.0,  0.0, -1.0, 0.0, 1.0, 1.0,
             1.0, -1.0,  1.0,  0.0, -1.0, 0.0, 1.0, 0.0,
            -1.0, -1.0,  1.0,  0.0, -1.0, 0.0, 0.0, 0.0,

            // Right face
             1.0, -1.0, -1.0,  1.0, 0.0, 0.0,  0.0, 0.0,
             1.0,  1.0, -1.0,  1.0, 0.0, 0.0,  1.0, 0.0,
             1.0,  1.0,  1.0,  1.0, 0.0, 0.0,  1.0, 1.0,
             1.0, -1.0,  1.0,  1.0, 0.0, 0.0,  0.0, 1.0,

            // Left face
            -1.0, -1.0, -1.0, -1.0, 0.0, 0.0,  1.0, 0.0,
            -1.0,  1.0, -1.0, -1.0, 0.0, 0.0,  0.0, 0.0,
            -1.0,  1.0,  1.0, -1.0, 0.0, 0.0,  0.0, 1.0,
            -1.0, -1.0,  1.0, -1.0, 0.0, 0.0,  1.0, 1.0,
        ]);
        const indices = new Uint32Array([
            0, 1, 2,    0, 2, 3,    // Front face
            4, 5, 6,    4, 6, 7,    // Back face
            8, 9, 10,   8, 10, 11,  // Top face
            12, 13, 14, 12, 14, 15, // Bottom face
            16, 17, 18, 16, 18, 19, // Right face
            20, 21, 22, 20, 22, 23, // Left face
        ]);

        return {
            geometries: [{
                name: 'zombie_mesh', // Hardcoded for now
                vertices: vertices,
                indices: indices,
                vertexStride: 8 * 4, // pos(3) + normal(3) + uv(2)
                attributes: [
                    { shaderLocation: 0, offset: 0, format: "float32x3" }, // position
                    { shaderLocation: 1, offset: 3 * 4, format: "float32x3" }, // normal
                    { shaderLocation: 2, offset: 6 * 4, format: "float32x2" }, // uv
                ]
            },
            {
                name: 'delorean_mesh', // Another mock mesh
                vertices: vertices, // Same dummy vertices for now
                indices: indices,
                vertexStride: 8 * 4, // pos(3) + normal(3) + uv(2)
                attributes: [
                    { shaderLocation: 0, offset: 0, format: "float32x3" },
                    { shaderLocation: 1, offset: 3 * 4, format: "float32x3" },
                    { shaderLocation: 2, offset: 6 * 4, format: "float32x2" },
                ]
            }]
        };
    }

    // Conceptual function to load WASM shaders
    async function loadWASMShader(path) {
        // In a real scenario, this would fetch the .wgsl file
        // For this conceptual example, we return the hardcoded string
        switch (path) {
            case 'shaders/opaque.wgsl': return opaqueWGSL;
            case 'shaders/transparent.wgsl': return transparentWGSL;
            case 'shaders/effects.wgsl': return effectsWGSL;
            case 'shaders/delorean.wgsl': return deloreanWGSL;
            case 'shaders/sky.wgsl': return skyWGSL;
            case 'shaders/postProcess.wgsl': return postProcessWGSL;
            default: throw new Error(`Shader not found: ${path}`);
        }
    }

    // Conceptual function to initialize WebGPU (replaces parts of old RenderEngine.init)
    async function initWebGPU() {
        const canvas = document.querySelector('canvas');
        const adapter = await navigator.gpu.requestAdapter({
            powerPreference: 'high-performance'
        });
        const device = await adapter.requestDevice();

        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
            device: device,
            format: format,
            alphaMode: 'opaque',
            size: [canvas.width, canvas.height] // Set initial size
        });

        return { device, canvas, context, format };
    }

    // Inizializzazione delle pipeline principali
    async function initPipelines(device, format) {
        // Pipeline per oggetti opachi (terreno, rocce, edifici)
        const opaquePipeline = await createOpaquePipeline(device, format);

        // Pipeline per oggetti trasparenti (acqua, particelle)
        const transparentPipeline = await createTransparentPipeline(device, format);

        // Pipeline per effetti speciali (luci, particelle)
        const effectsPipeline = await createEffectsPipeline(device, format);

        // Pipeline per la DeLorean (materiali speciali)
        const deloreanPipeline = await createDeloreanPipeline(device, format);

        // Pipeline per lo skybox
        const skyPipeline = await createSkyPipeline(device, format);

        // Pipeline for particles (rendering)
        const particleRenderPipeline = await createParticleRenderPipeline(device, format);

        // Pipeline for post-processing
        const postProcessPipeline = await createPostProcessPipeline(device, format);


        return {
            opaque: opaquePipeline,
            transparent: transparentPipeline,
            effects: effectsPipeline,
            delorean: deloreanPipeline,
            sky: skyPipeline,
            particleRender: particleRenderPipeline,
            postProcess: postProcessPipeline
        };
    }

    async function createOpaquePipeline(device, format) {
        const shaderModule = device.createShaderModule({
            code: await loadWASMShader('shaders/opaque.wgsl')
        });

        const pipeline = await device.createRenderPipelineAsync({
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [
                    { // Vertex buffer
                        arrayStride: 8 * 4, // pos(3) + normal(3) + uv(2)
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: "float32x3" }, // position
                            { shaderLocation: 1, offset: 3 * 4, format: "float32x3" }, // normal
                            { shaderLocation: 2, offset: 6 * 4, format: "float32x2" }, // uv
                        ]
                    },
                    { // Instance buffer (for modelMatrix, normalMatrix, materialID)
                        arrayStride: (16 + 9 + 1) * 4, // glMatrix.mat4(16 floats) + glMatrix.mat3(9 floats) + materialID(1 float) = 26 floats * 4 bytes/float = 104 bytes
                        stepMode: 'instance',
                        attributes: [
                            { shaderLocation: 4, offset: 0 * 4, format: "float32x4" },
                            { shaderLocation: 5, offset: 4 * 4, format: "float32x4" },
                            { shaderLocation: 6, offset: 8 * 4, format: "float32x4" },
                            { shaderLocation: 7, offset: 12 * 4, format: "float32x4" }, // modelMatrix
                            { shaderLocation: 8, offset: 16 * 4, format: "float32x3" },
                            { shaderLocation: 9, offset: 19 * 4, format: "float32x3" },
                            { shaderLocation: 10, offset: 22 * 4, format: "float32x3" }, // normalMatrix (first 9 floats of 3x3)
                            { shaderLocation: 11, offset: 25 * 4, format: "uint32" } // materialID
                        ]
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [{
                    format: format,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one-minus-src-alpha',
                            operation: 'add'
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one-minus-src-alpha',
                            operation: 'add'
                        }
                    }
                }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back'
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less-equal', // Changed to less-equal
                format: 'depth24plus-stencil8'
            },
            layout: 'auto'
        });

        return pipeline;
    }

    async function createTransparentPipeline(device, format) {
        const shaderModule = device.createShaderModule({
            code: await loadWASMShader('shaders/transparent.wgsl')
        });

        const pipeline = await device.createRenderPipelineAsync({
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [
                    { // Vertex buffer
                        arrayStride: 8 * 4, // pos(3) + normal(3) + uv(2)
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: "float32x3" }, // position
                            { shaderLocation: 1, offset: 3 * 4, format: "float32x3" }, // normal
                            { shaderLocation: 2, offset: 6 * 4, format: "float32x2" }, // uv
                        ]
                    },
                    { // Instance buffer
                        arrayStride: (16 + 9 + 1) * 4, // glMatrix.mat4(16 floats) + glMatrix.mat3(9 floats) + materialID(1 float) = 26 floats * 4 bytes/float = 104 bytes
                        stepMode: 'instance',
                        attributes: [
                            { shaderLocation: 4, offset: 0 * 4, format: "float32x4" },
                            { shaderLocation: 5, offset: 4 * 4, format: "float32x4" },
                            { shaderLocation: 6, offset: 8 * 4, format: "float32x4" },
                            { shaderLocation: 7, offset: 12 * 4, format: "float32x4" }, // modelMatrix
                            { shaderLocation: 8, offset: 16 * 4, format: "float32x3" },
                            { shaderLocation: 9, offset: 19 * 4, format: "float32x3" },
                            { shaderLocation: 10, offset: 22 * 4, format: "float32x3" }, // normalMatrix (first 9 floats of 3x3)
                            { shaderLocation: 11, offset: 25 * 4, format: "uint32" } // materialID
                        ]
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [{
                    format: format,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one-minus-src-alpha',
                            operation: 'add'
                        },
                        alpha: {
                            srcFactor: 'one',
                            dstFactor: 'one-minus-src-alpha',
                            operation: 'add'
                        }
                    }
                }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back'
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less-equal', // Changed to less-equal
                format: 'depth24plus-stencil8'
            },
            layout: 'auto'
        });

        return pipeline;
    }

    async function createEffectsPipeline(device, format) {
        const shaderModule = device.createShaderModule({
            code: await loadWASMShader('shaders/effects.wgsl')
        });

        return await device.createRenderPipelineAsync({
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [{
                    arrayStride: 6 * 4, // position (vec3f) + color (vec3f)
                    attributes: [
                        { format: 'float32x3', offset: 0, shaderLocation: 0 },
                        { format: 'float32x3', offset: 3 * 4, shaderLocation: 1 }
                    ]
                }]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [{
                    format: format,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                            operation: 'add'
                        },
                        alpha: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                            operation: 'add'
                        }
                    }
                }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'none'
            },
            depthStencil: {
                depthWriteEnabled: false, // Effects often don't write to depth
                depthCompare: 'less',
                format: 'depth24plus-stencil8'
            },
            layout: 'auto'
        });
    }

    async function createDeloreanPipeline(device, format) {
        const shaderModule = device.createShaderModule({
            code: await loadWASMShader('shaders/delorean.wgsl')
        });

        const pipeline = await device.createRenderPipelineAsync({
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [
                    { // Vertex buffer
                        arrayStride: 8 * 4, // pos(3) + normal(3) + uv(2)
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: "float32x3" }, // position
                            { shaderLocation: 1, offset: 3 * 4, format: "float32x3" }, // normal
                            { shaderLocation: 2, offset: 6 * 4, format: "float32x2" }, // uv
                        ]
                    },
                    { // Instance buffer
                        arrayStride: (16 + 9 + 1) * 4, // glMatrix.mat4(16 floats) + glMatrix.mat3(9 floats) + materialID(1 float) = 26 floats * 4 bytes/float = 104 bytes
                        stepMode: 'instance',
                        attributes: [
                            { shaderLocation: 4, offset: 0 * 4, format: "float32x4" },
                            { shaderLocation: 5, offset: 4 * 4, format: "float32x4" },
                            { shaderLocation: 6, offset: 8 * 4, format: "float32x4" },
                            { shaderLocation: 7, offset: 12 * 4, format: "float32x4" }, // modelMatrix
                            { shaderLocation: 8, offset: 16 * 4, format: "float32x3" },
                            { shaderLocation: 9, offset: 19 * 4, format: "float32x3" },
                            { shaderLocation: 10, offset: 22 * 4, format: "float32x3" }, // normalMatrix (first 9 floats of 3x3)
                            { shaderLocation: 11, offset: 25 * 4, format: "uint32" } // materialID
                        ]
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [{ format: format }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back'
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus-stencil8'
            },
            layout: 'auto'
        });

        return pipeline;
    }

    async function createSkyPipeline(device, format) {
        const shaderModule = device.createShaderModule({
            code: await loadWASMShader('shaders/sky.wgsl')
        });

        const pipeline = await device.createRenderPipelineAsync({
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [{
                    arrayStride: 3 * 4, // position (vec3f)
                    attributes: [
                        { format: 'float32x3', offset: 0, shaderLocation: 0 },
                    ]
                }]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [{ format: format }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'front' // Render front face for skybox
            },
            depthStencil: {
                depthWriteEnabled: false, // Skybox should not write to depth
                depthCompare: 'less-equal', // Render at max depth
                format: 'depth24plus-stencil8'
            },
            layout: 'auto'
        });

        return pipeline;
    }

    async function createParticleRenderPipeline(device, format) {
        const pipeline = await device.createRenderPipelineAsync({
            vertex: {
                module: device.createShaderModule({ code: `
                    struct ParticleVertexInput {
                        @location(0) position: vec3f,
                        @location(1) color: vec4f,
                    };
                    struct VertexOutput {
                        @builtin(position) position: vec4f,
                        @location(0) color: vec4f,
                    };
                    @group(0) @binding(2) var<uniform> cameraViewProjection: mat4x4f;
                    @vertex
                    fn vertexMain(input: ParticleVertexInput) -> VertexOutput {
                        var output: VertexOutput;
                        output.position = cameraViewProjection * vec4f(input.position, 1.0);
                        output.color = input.color;
                        return output;
                    }
                `}),
                entryPoint: 'vertexMain',
                buffers: [{
                    arrayStride: 44, // position (vec3f, 12 bytes) + velocity (vec3f, 12 bytes) + color (vec4f, 16 bytes) + lifetime (f32, 4 bytes) = 44 bytes
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: "float32x3" }, // position
                        { shaderLocation: 1, offset: 24, format: "float32x4" } // color (offset after position and velocity)
                    ]
                }]
            },
            fragment: {
                module: device.createShaderModule({ code: `
                    struct FragmentInput {
                        @location(0) color: vec4f,
                    };
                    @fragment
                    fn fragmentMain(input: FragmentInput) -> @location(0) vec4f {
                        return input.color;
                    }
                `}),
                entryPoint: 'fragmentMain',
                targets: [{ format: format, blend: {
                    color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                    alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                } }]
            },
            primitive: {
                topology: 'point-list', // Render particles as points
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus-stencil8',
            },
            layout: 'auto',
        });
        return pipeline;
    }

    async function createPostProcessPipeline(device, format) {
        const shaderModule = device.createShaderModule({
            code: await loadWASMShader('shaders/postProcess.wgsl')
        });

        const pipeline = await device.createRenderPipelineAsync({
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [] // Full-screen quad, vertices generated in shader
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [{ format: format }]
            },
            primitive: {
                topology: 'triangle-strip', // For full-screen quad
                stripIndexFormat: 'uint32',
            },
            layout: 'auto'
        });
        return pipeline;
    }

    // Material definitions for instanced rendering
    const materialDefinitions = [
        { // Material ID 0: Default Zombie
            baseColor: [0.7, 0.3, 0.3, 1.0], // Reddish
            roughness: 0.8,
            metallic: 0.1,
            specular: 0.2
        },
        { // Material ID 1: Lightning Zombie
            baseColor: [0.3, 0.7, 0.7, 1.0], // Cyan/Blueish
            roughness: 0.4,
            metallic: 0.3,
            specular: 0.5
        },
        { // Material ID 2: DeLorean
            baseColor: [0.5, 0.5, 0.5, 1.0], // Grey
            roughness: 0.2,
            metallic: 0.9,
            specular: 0.8
        },
        { // Material ID 3: Kamikaze Bunny
            baseColor: [0.9, 0.6, 0.2, 1.0], // Orange/Brownish
            roughness: 0.7,
            metallic: 0.1,
            specular: 0.3
        }
        // Add more materials as needed
    ];

    function createTerrainMaterial(device) {
        // This material is not instanced, so it uses simpler uniforms
        const terrainUniformBuffer = device.createBuffer({
            size: 16 * 4, // matrice 4x4
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });

        const terrainBindGroupLayout = device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: { sampleType: 'float' }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: { type: 'filtering' }
                }
            ]
        });

        return {
            buffer: terrainUniformBuffer,
            layout: terrainBindGroupLayout,
            texture: null, // Verrà caricato dopo
            sampler: device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                mipmapFilter: 'linear', // Added mipmapFilter
                addressModeU: 'repeat',
                addressModeV: 'repeat'
            })
        };
    }

    function createDeloreanMaterial(device) {
        // This material is instanced for the DeLorean, but its properties are still defined here
        // The material properties (baseColor, roughness, metallic, specular) will be fetched from materialDefinitions array in the shader
        const deloreanUniformBuffer = device.createBuffer({
            size: 16 * 4 + 16 * 4 + 4 * 4, // matrice + normale + parametri
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });

        const deloreanBindGroupLayout = device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' }
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: { sampleType: 'float' }
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: { type: 'filtering' }
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' } // time uniform
                },
            ]
        });

        const deloreanMaterialBindGroupLayout = device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform', hasDynamicOffset: false, minBindingSize: 32 * materialDefinitions.length } // Array of MaterialParams (32 bytes per struct)
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' } // cameraPos
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: { viewDimension: 'cube' } // reflectionMap
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: { type: 'filtering' } // reflectionSampler
                },
                {
                    binding: 4,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: { sampleType: 'float' } // emissionMap
                },
                {
                    binding: 5,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' } // emissionStrength
                }
            ]
        });


        // Dummy cube map for reflection (6 faces, 1x1 pixel each)
        const reflectionCubeTexture = device.createTexture({
            dimension: 'cube',
            size: [1, 1, 6],
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
        });
        const dummyPixel = new Uint8Array([25, 25, 50, 255]); // Dark blueish
        for (let i = 0; i < 6; ++i) {
            device.queue.writeTexture(
                { texture: reflectionCubeTexture, arrayLayer: i },
                dummyPixel,
                { layout: { offset: 0, bytesPerRow: 4, rowsPerImage: 1 } },
                [1, 1]
            );
        }

        // Dummy emission texture (1x1 white pixel)
        const emissionTexture = device.createTexture({
            size: [1, 1, 1],
            format: 'rgba8unorm',
            usage: GPUBufferUsage.TEXTURE_BINDING | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeTexture(
            { texture: emissionTexture },
            new Uint8Array([255, 255, 255, 255]),
            { layout: { offset: 0, bytesPerRow: 4, rowsPerImage: 1 } },
            [1, 1]
        );

        return {
            buffer: deloreanUniformBuffer,
            layout: deloreanBindGroupLayout,
            materialLayout: deloreanMaterialBindGroupLayout, // New layout for materials
            texture: null, // Base color texture, will be loaded
            sampler: device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                mipmapFilter: 'linear', // Added mipmapFilter
                addressModeU: 'repeat',
                addressModeV: 'repeat'
            }),
            timeBuffer: device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            }),
            cameraPosBuffer: device.createBuffer({
                size: 16, // vec3f + padding
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            }),
            reflectionCubeTexture: reflectionCubeTexture,
            reflectionSampler: device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                mipmapFilter: 'linear', // Added mipmapFilter
            }),
            emissionTexture: emissionTexture,
            emissionStrengthBuffer: device.createBuffer({
                size: 4, // f32
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            })
        };
    }

    function createWaterMaterial(device) {
        // Placeholder for water material
        return {
            buffer: device.createBuffer({ size: 16 * 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }),
            layout: device.createBindGroupLayout({ entries: [] }), // Empty for now
            texture: null,
            sampler: device.createSampler({})
        };
    }

    function createTerrainGeometry(device) {
        const gridSize = 100; // Number of vertices along one side
        const cellSize = 2;   // Size of each grid cell
        const terrainScale = 0.5; // Scale for height variation
        const terrainHeight = 10; // Max height of terrain

        const vertices = [];
        const indices = [];

        // Generate vertices, normals, and UVs
        for (let i = 0; i <= gridSize; i++) {
            for (let j = 0; j <= gridSize; j++) {
                const x = (j - gridSize / 2) * cellSize;
                const z = (i - gridSize / 2) * cellSize;
                const y = Math.sin(x * terrainScale * 0.1) * Math.cos(z * terrainScale * 0.1) * terrainHeight;

                vertices.push(x, y, z); // Position

                // Dummy normal for now, should be calculated based on surrounding vertices
                // For a more accurate normal, you'd need to calculate cross products of triangle edges.
                // For simplicity, let's assume a basic upward normal, or a flat normal for now.
                // A better approach would be to calculate normals after all vertices are defined.
                // For conceptual purposes, let's use a simplified normal that points mostly up.
                const nx = -terrainHeight * 0.1 * Math.cos(x * terrainScale * 0.1) * Math.cos(z * terrainScale * 0.1);
                const nz = terrainHeight * 0.1 * Math.sin(x * terrainScale * 0.1) * Math.sin(z * terrainScale * 0.1);
                const ny = 1.0; // Assume mostly flat, so Y is dominant
                const normal = glMatrix.vec3.normalize(glMatrix.vec3.create(), [nx, ny, nz]); // glMatrix.vec3.normalize: Normalizza un vettore 3D. glMatrix.vec3.create: Crea un nuovo vettore 3D.
                vertices.push(normal[0], normal[1], normal[2]); // Normal

                vertices.push(j / gridSize, i / gridSize); // UVs
            }
        }

        // Generate indices for triangles
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const p0 = i * (gridSize + 1) + j;
                const p1 = p0 + 1;
                const p2 = (i + 1) * (gridSize + 1) + j;
                const p3 = p2 + 1;

                // Triangle 1
                indices.push(p0, p2, p1);
                // Triangle 2
                indices.push(p1, p2, p3);
            }
        }

        const vertexBuffer = device.createBuffer({
            size: new Float32Array(vertices).byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
        vertexBuffer.unmap();

        const indexBuffer = device.createBuffer({
            size: new Uint32Array(indices).byteLength,
            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Uint32Array(indexBuffer.getMappedRange()).set(indices);
        indexBuffer.unmap();

        return {
            vertexBuffer,
            indexBuffer,
            indexCount: indices.length
        };
    }

    function createDeloreanGeometry(device) {
        // Dummy geometry for DeLorean (a simple cube)
        const vertices = new Float32Array([
            // positions (x,y,z), normals (nx,ny,nz), uvs (u,v)
            // Front face
            -1.0, -1.0,  1.0,  0.0, 0.0, 1.0,  0.0, 0.0,
             1.0, -1.0,  1.0,  0.0, 0.0, 1.0,  1.0, 0.0,
             1.0,  1.0,  1.0,  0.0, 0.0, 1.0,  1.0, 1.0,
            -1.0,  1.0,  1.0,  0.0, 0.0, 1.0,  0.0, 1.0,

            // Back face
            -1.0, -1.0, -1.0,  0.0, 0.0, -1.0, 1.0, 0.0,
             1.0, -1.0, -1.0,  0.0, 0.0, -1.0, 0.0, 0.0,
             1.0,  1.0, -1.0,  0.0, 0.0, -1.0, 0.0, 1.0,
            -1.0,  1.0, -1.0,  0.0, 0.0, -1.0, 1.0, 1.0,

            // Top face
            -1.0,  1.0, -1.0,  0.0, 1.0, 0.0,  0.0, 1.0,
             1.0,  1.0, -1.0,  0.0, 1.0, 0.0,  1.0, 1.0,
             1.0,  1.0,  1.0,  0.0, 1.0, 0.0,  1.0, 0.0,
            -1.0,  1.0,  1.0,  0.0, 1.0, 0.0,  0.0, 0.0,

            // Bottom face
            -1.0, -1.0, -1.0,  0.0, -1.0, 0.0, 0.0, 1.0,
             1.0, -1.0, -1.0,  0.0, -1.0, 0.0, 1.0, 1.0,
             1.0, -1.0,  1.0,  0.0, -1.0, 0.0, 1.0, 0.0,
            -1.0, -1.0,  1.0,  0.0, -1.0, 0.0, 0.0, 0.0,

            // Right face
             1.0, -1.0, -1.0,  1.0, 0.0, 0.0,  0.0, 0.0,
             1.0,  1.0, -1.0,  1.0, 0.0, 0.0,  1.0, 0.0,
             1.0,  1.0,  1.0,  1.0, 0.0, 0.0,  1.0, 1.0,
             1.0, -1.0,  1.0,  1.0, 0.0, 0.0,  0.0, 1.0,

            // Left face
            -1.0, -1.0, -1.0, -1.0, 0.0, 0.0,  1.0, 0.0,
            -1.0,  1.0, -1.0, -1.0, 0.0, 0.0,  0.0, 0.0,
            -1.0,  1.0,  1.0, -1.0, 0.0, 0.0,  0.0, 1.0,
            -1.0, -1.0,  1.0, -1.0, 0.0, 0.0,  1.0, 1.0,
        ]);
        const indices = new Uint32Array([
            0, 1, 2,    0, 2, 3,    // Front face
            4, 5, 6,    4, 6, 7,    // Back face
            8, 9, 10,   8, 10, 11,  // Top face
            12, 13, 14, 12, 14, 15, // Bottom face
            16, 17, 18, 16, 18, 19, // Right face
            20, 21, 22, 20, 22, 23, // Left face
        ]);

        const vertexBuffer = device.createBuffer({
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
        vertexBuffer.unmap();

        const indexBuffer = device.createBuffer({
            size: indices.byteLength,
            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Uint32Array(indexBuffer.getMappedRange()).set(indices);
        indexBuffer.unmap();

        return {
            vertexBuffer,
            indexBuffer,
            indexCount: indices.length
        };
    }

    /**
     * Conceptual GPUBufferAllocator for suballocation.
     * A full implementation would involve more sophisticated memory management
     * like a free list or buddy allocation. For this demo, it's a simple linear allocator.
     * This class is currently not used, but kept for conceptual completeness.
     */
    class GPUBufferAllocator {
        constructor(device, size, usage) {
            this.device = device;
            this.buffer = device.createBuffer({ size, usage });
            this.size = size;
            this.offset = 0;
            this.allocations = new Map(); // Map<key, {offset, size}>
            console.log(`GPUBufferAllocator created with size: ${size} bytes`);
        }

        /**
         * Allocates a sub-range within the buffer.
         * @param {string} key A unique identifier for the allocation.
         * @param {number} size The size in bytes to allocate.
         * @returns {{buffer: GPUBuffer, offset: number}|null} The buffer and its offset, or null if allocation fails.
         */
        allocate(key, size) {
            // Simple linear allocation for demonstration
            if (this.offset + size > this.size) {
                console.warn(`GPUBufferAllocator: Not enough space for key '${key}', requested ${size} bytes.`);
                return null;
            }

            const currentOffset = this.offset;
            this.offset += size;
            this.allocations.set(key, { offset: currentOffset, size: size });
            console.log(`GPUBufferAllocator: Allocated ${size} bytes for '${key}' at offset ${currentOffset}.`);
            return { buffer: this.buffer, offset: currentOffset };
        }

        /**
         * Frees a previously allocated sub-range. (Conceptual, linear allocator doesn't truly free)
         * @param {string} key The key of the allocation to free.
         */
        free(key) {
            if (this.allocations.has(key)) {
                const allocation = this.allocations.get(key);
                console.log(`GPUBufferAllocator: Freed allocation for '${key}' (offset: ${allocation.offset}, size: ${allocation.size}).`);
                this.allocations.delete(key);
                // In a real allocator, this space would be marked as free.
            }
        }

        /**
         * Gets a previously allocated sub-range.
         * @param {string} key The key of the allocation to retrieve.
         * @returns {{buffer: GPUBuffer, offset: number}|null}
         */
        get(key) {
            const allocation = this.allocations.get(key);
            if (allocation) {
                return { buffer: this.buffer, offset: allocation.offset };
            }
            return null;
        }
    }


    class WebGPURenderer {
        constructor() {
            this.device = null;
            this.canvas = null;
            this.context = null;
            this.format = null;
            this.pipelines = null;
            this.materials = {};
            this.geometries = {};
            this.depthTexture = null;
            this.aspectRatio = 1;

            // Common resources
            this.uniformBuffer = null; // For camera MVP
            this.lightBuffer = null;   // For lights (lightDirection, ambientColor)
            this.materialParamsBuffer = null; // For dynamic material parameters (array of structs)
            this.deloreanTimeBuffer = null; // For DeLorean shader time

            // Instanced renderers
            this.zombieInstancer = null;
            this.deloreanInstancer = null;

            // Particle system
            this.particleSystem = null;

            // Post-processing
            this.renderTargetTexture = null;
            this.renderTargetTextureView = null;
            this.renderTargetSampler = null;
            this.postProcessResolutionBuffer = null;
            this.postProcessTimeBuffer = null;

            // Bind Group Caching
            this.bindGroupCache = new Map();
        }

        async init() {
            const { device, canvas, context, format } = await initWebGPU();
            this.device = device;
            this.canvas = canvas;
            this.context = context;
            this.format = format;
            this.aspectRatio = this.canvas.width / this.canvas.height;

            // Initialize common resources
            this.uniformBuffer = this.device.createBuffer({
                size: 256, // Matrici 4x4 for camera (MVP) + camera position
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            this.lightBuffer = this.device.createBuffer({
                size: 4 * 4 + 4 * 4, // vec3f lightDirection + vec3f ambientColor (with padding)
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Material properties buffer (array of structs)
            // Each MaterialParams struct is 4 * 4 = 16 bytes (vec4f + 3 f32 + padding)
            this.materialParamsBuffer = this.device.createBuffer({
                size: 32 * materialDefinitions.length, // Corrected size: 32 bytes per material struct
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            // Write initial material data
            this._updateMaterialParamsBuffer();


            this.deloreanTimeBuffer = this.device.createBuffer({
                size: 4, // f32
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });


            // Depth texture
            this.depthTexture = this.device.createTexture({
                size: [this.canvas.width, this.canvas.height],
                format: 'depth24plus-stencil8',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });

            // Post-processing render target
            this.renderTargetTexture = this.device.createTexture({
                size: [this.canvas.width, this.canvas.height],
                format: this.format,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
            });
            this.renderTargetTextureView = this.renderTargetTexture.createView();
            this.renderTargetSampler = this.device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                mipmapFilter: 'linear', // Added mipmapFilter to post-processing sampler
            });
            this.postProcessResolutionBuffer = this.device.createBuffer({
                size: 8, // vec2f
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            this.postProcessTimeBuffer = this.device.createBuffer({
                size: 4, // f32
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });


            this.pipelines = await initPipelines(device, format);
            this.initMaterials();
            this.initGeometries();

            // Initialize instanced renderers
            this.zombieInstancer = new InstancedRenderer(this.device, 'zombie_mesh', MAX_ZOMBIES);
            this.deloreanInstancer = new InstancedRenderer(this.device, 'delorean_mesh', 1);

            // Initialize particle system
            this.particleSystem = new ParticleSystem(this.device);
            await this.particleSystem.init();

            this._setupEventHandlers();
        }

        _updateMaterialParamsBuffer() {
            // Each MaterialParams struct is 32 bytes (8 floats)
            const materialData = new Float32Array(materialDefinitions.length * 8); // 8 floats per material

            materialDefinitions.forEach((mat, i) => {
                const offset = i * 8; // 8 floats per material
                materialData.set(mat.baseColor, offset); // baseColor (vec4f, 4 floats)
                materialData[offset + 4] = mat.roughness;
                materialData[offset + 5] = mat.metallic;
                materialData[offset + 6] = mat.specular;
                // offset + 7 is padding
            });
            this.device.queue.writeBuffer(this.materialParamsBuffer, 0, materialData);
        }


        initMaterials() {
            this.materials.terrain = createTerrainMaterial(this.device);
            this.materials.delorean = createDeloreanMaterial(this.device);
            this.materials.water = createWaterMaterial(this.device);
            // Add other materials...

            // Placeholder for default material texture and sampler for main pipeline
            this.materials.defaultTexture = this.device.createTexture({
                size: [1, 1, 1],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                dimension: '2d',
                arrayLayerCount: 1,
            });
            this.device.queue.writeTexture(
                { texture: this.materials.defaultTexture },
                new Uint8Array([255, 255, 255, 255]),
                { layout: { offset: 0, bytesPerRow: 4, rowsPerImage: 1 } },
                [1, 1]
            );
            this.materials.defaultSampler = this.device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                mipmapFilter: 'linear', // Added mipmapFilter
            });
        }

        initGeometries() {
            this.geometries.terrain = createTerrainGeometry(this.device);
            this.geometries.delorean = createDeloreanGeometry(this.device);
            this.geometries.skybox = createDeloreanGeometry(this.device); // Reusing cube for skybox
            // Add other geometries...
        }

        _setupEventHandlers() {
            window.addEventListener('resize', () => {
                const [optimalWidth, optimalHeight] = getOptimalResolution();
                this.canvas.width = optimalWidth;
                this.canvas.height = optimalHeight;
                this.aspectRatio = this.canvas.width / this.canvas.height;
                // Recreate depth texture on resize
                if (this.depthTexture) this.depthTexture.destroy(); // Destroy previous texture
                this.depthTexture = this.device.createTexture({
                    size: [this.canvas.width, this.canvas.height],
                    format: 'depth24plus-stencil8',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                });
                this.context.configure({
                    device: this.device,
                    format: this.format,
                    alphaMode: 'opaque',
                    size: [this.canvas.width, this.canvas.height],
                });

                // Recreate render target texture on resize
                if (this.renderTargetTexture) this.renderTargetTexture.destroy(); // Destroy previous texture
                this.renderTargetTexture = this.device.createTexture({
                    size: [this.canvas.width, this.canvas.height],
                    format: this.format,
                    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
                });
                this.renderTargetTextureView = this.renderTargetTexture.createView();
            });
        }

        /**
         * Generic helper to create and cache bind groups.
         * @param {GPUBindGroupLayout} layout The bind group layout.
         * @param {Array<GPUBindGroupEntry>} entries The entries for the bind group.
         * @returns {GPUBindGroup} The created or cached bind group.
         */
        _getBindGroup(layout, entries) {
            // Generate a unique key for the bind group based on its layout and entries
            // This is a simplified key generation; for complex scenarios, you might hash resource IDs.
            // Using a simple string concatenation of binding numbers and resource types/labels.
            const keyParts = [layout.label || layout.toString()]; // Use label if available, otherwise stringify layout
            entries.forEach(e => {
                keyParts.push(`b${e.binding}`);
                if (e.resource.buffer) {
                    keyParts.push(`buf-${e.resource.buffer.label || e.resource.buffer.toString()}-${e.resource.offset || 0}-${e.resource.buffer.size}`);
                } else if (e.resource.texture) {
                    keyParts.push(`tex-${e.resource.texture.label || e.resource.texture.toString()}`);
                } else if (e.resource.sampler) {
                    keyParts.push(`samp-${e.resource.sampler.label || e.resource.sampler.toString()}`);
                } else if (e.resource.textureView) { // For texture views
                    keyParts.push(`texview-${e.resource.textureView.label || e.resource.textureView.toString()}`);
                }
            });
            const key = keyParts.join('_');

            if (this.bindGroupCache.has(key)) {
                return this.bindGroupCache.get(key);
            }

            const bindGroup = this.device.createBindGroup({ layout, entries });
            this.bindGroupCache.set(key, bindGroup);
            return bindGroup;
        }

        render(scene, camera, deltaTime) {
            const commandEncoder = this.device.createCommandEncoder();

            // Measure performance with debug groups (conceptual)
            commandEncoder.pushDebugGroup('Main Render Pass');

            // Update camera uniform buffer
            // glMatrix.mat4.perspective: Calcola una matrice di proiezione prospettica.
            glMatrix.mat4.perspective(gameEngine.cameraProjectionMatrix, // Use gameEngine's pre-allocated matrix
                glMatrix.toRadian(camera.fov), // glMatrix.toRadian: Converte gradi in radianti.
                this.aspectRatio,
                camera.near,
                camera.far
            );
            // glMatrix.mat4.lookAt: Calcola una matrice di vista (view matrix) dalla posizione della telecamera, dal punto di mira e dal vettore "su".
            glMatrix.mat4.lookAt(gameEngine.cameraViewMatrix, // Use gameEngine's pre-allocated matrix
                camera.position,
                camera.target,
                camera.up
            );
            // glMatrix.mat4.multiply: Moltiplica due matrici 4x4.
            glMatrix.mat4.multiply(gameEngine.cameraViewProjectionMatrix, gameEngine.cameraProjectionMatrix, gameEngine.cameraViewMatrix); // Use gameEngine's pre-allocated matrix

            this.device.queue.writeBuffer(
                this.uniformBuffer,
                0,
                gameEngine.cameraViewProjectionMatrix.buffer // Write the combined MVP matrix
            );
            this.device.queue.writeBuffer(
                this.uniformBuffer,
                64, // Offset per la posizione della telecamera (vec3f è 12 byte, quindi dopo 16 float di glMatrix.mat4)
                new Float32Array(camera.position).buffer
            );

            // Update light uniform buffer (example: one light)
            const lightData = new Float32Array([
                // lightDirection (vec3f) + padding
                1.0, 1.0, 0.5, 0.0,
                // ambientColor (vec3f) + padding
                0.1, 0.1, 0.1, 0.0
            ]);
            this.device.queue.writeBuffer(this.lightBuffer, 0, lightData);

            // Update material parameters buffer (array of structs)
            this._updateMaterialParamsBuffer(); // Ensure materials are up-to-date

            // Update DeLorean time buffer
            this.device.queue.writeBuffer(this.deloreanTimeBuffer, 0, new Float32Array([performance.now() / 1000]));


            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: this.renderTargetTextureView, // Render to intermediate texture
                    clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }],
                depthStencilAttachment: {
                    view: this.depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store'
                }
            });

            // Render Skybox first
            commandEncoder.pushDebugGroup('Render Skybox');
            if (this.pipelines.sky && this.geometries.skybox) {
                renderPass.setPipeline(this.pipelines.sky);
                renderPass.setBindGroup(0, this._getBindGroup(this.pipelines.sky.getBindGroupLayout(0), [
                    { binding: 0, resource: { buffer: this.uniformBuffer } } // Only view_projection
                ]));
                renderPass.setVertexBuffer(0, this.geometries.skybox.vertexBuffer);
                renderPass.setIndexBuffer(this.geometries.skybox.indexBuffer, 'uint32');
                renderPass.drawIndexed(this.geometries.skybox.indexCount);
            }
            commandEncoder.popDebugGroup(); // End Render Skybox

            // Render Opaque Objects (e.g., terrain, zombies)
            commandEncoder.pushDebugGroup('Render Opaque Objects');
            if (this.pipelines.opaque) {
                renderPass.setPipeline(this.pipelines.opaque);
                // Bind groups for opaque objects
                renderPass.setBindGroup(0, this._getBindGroup(this.pipelines.opaque.getBindGroupLayout(0), [
                    { binding: 0, resource: { buffer: this.uniformBuffer } }, // Camera MVP
                    { binding: 1, resource: this.materials.defaultTexture.createView() }, // Placeholder texture
                    { binding: 2, resource: this.materials.defaultSampler } // Placeholder sampler
                ]));
                // Bind Group 1 for material parameters array
                renderPass.setBindGroup(1, this._getBindGroup(this.pipelines.opaque.getBindGroupLayout(1), [
                    { binding: 0, resource: { buffer: this.materialParamsBuffer } } // Material parameters array
                ]));
                // Bind Group 2 for lights (conceptual, would be per-light or global)
                renderPass.setBindGroup(2, this._getBindGroup(this.pipelines.opaque.getBindGroupLayout(2), [
                    { binding: 0, resource: { buffer: this.lightBuffer, offset: 0, size: 12 } }, // lightDirection
                    { binding: 1, resource: { buffer: this.lightBuffer, offset: 16, size: 12 } }  // ambientColor
                ]));


                // Render terrain
                if (this.geometries.terrain) {
                    renderPass.setVertexBuffer(0, this.geometries.terrain.vertexBuffer);
                    renderPass.setIndexBuffer(this.geometries.terrain.indexBuffer, 'uint32');
                    renderPass.drawIndexed(this.geometries.terrain.indexCount);
                }

                // Render zombies using instancing
                this.zombieInstancer.render(renderPass);
            }
            commandEncoder.popDebugGroup(); // End Render Opaque Objects

            // Render DeLorean (uses its own pipeline)
            commandEncoder.pushDebugGroup('Render DeLorean');
            if (this.pipelines.delorean) {
                renderPass.setPipeline(this.pipelines.delorean);
                // Update DeLorean material specific uniforms
                this.device.queue.writeBuffer(this.materials.delorean.timeBuffer, 0, new Float32Array([performance.now() / 1000]));
                this.device.queue.writeBuffer(this.materials.delorean.emissionStrengthBuffer, 0, new Float32Array([1.0])); // Example strength
                this.device.queue.writeBuffer(this.materials.delorean.cameraPosBuffer, 0, new Float32Array(camera.position));


                renderPass.setBindGroup(0, this._getBindGroup(this.pipelines.delorean.getBindGroupLayout(0), [
                    { binding: 0, resource: { buffer: this.uniformBuffer } }, // Camera MVP
                    { binding: 1, resource: this.materials.defaultTexture.createView() }, // Placeholder base color texture
                    { binding: 2, resource: this.materials.defaultSampler }, // Placeholder sampler
                    { binding: 3, resource: { buffer: this.materials.delorean.timeBuffer } } // Time for DeLorean effects
                ]));
                renderPass.setBindGroup(1, this._getBindGroup(this.materials.delorean.materialLayout, [ // Use materialLayout for DeLorean
                    { binding: 0, resource: { buffer: this.materialParamsBuffer } }, // Material parameters array
                    { binding: 1, resource: { buffer: this.materials.delorean.cameraPosBuffer } },
                    { binding: 2, resource: this.materials.delorean.reflectionCubeTexture.createView() },
                    { binding: 3, resource: this.materials.delorean.reflectionSampler },
                    { binding: 4, resource: this.materials.delorean.emissionTexture.createView() },
                    { binding: 5, resource: { buffer: this.materials.delorean.emissionStrengthBuffer } }
                ]));
                // Bind Group 2 for lights (conceptual)
                renderPass.setBindGroup(2, this._getBindGroup(this.pipelines.delorean.getBindGroupLayout(2), [
                    { binding: 0, resource: { buffer: this.lightBuffer, offset: 0, size: 12 } }, // lightDirection
                    { binding: 1, resource: { buffer: this.lightBuffer, offset: 16, size: 12 } }  // ambientColor
                ]));

                this.deloreanInstancer.render(renderPass);
            }
            commandEncoder.popDebugGroup(); // End Render DeLorean

            // Render Transparent Objects (e.g., water)
            commandEncoder.pushDebugGroup('Render Transparent Objects');
            if (this.pipelines.transparent) {
                renderPass.setPipeline(this.pipelines.transparent);
                // Bind groups for transparent objects (similar to opaque, but blend enabled)
                renderPass.setBindGroup(0, this._getBindGroup(this.pipelines.transparent.getBindGroupLayout(0), [
                    { binding: 0, resource: { buffer: this.uniformBuffer } },
                    { binding: 1, resource: this.materials.defaultTexture.createView() },
                    { binding: 2, resource: this.materials.defaultSampler }
                ]));
                renderPass.setBindGroup(1, this._getBindGroup(this.pipelines.transparent.getBindGroupLayout(1), [
                    { binding: 0, resource: { buffer: this.materialParamsBuffer } } // Material parameters array
                ]));
                renderPass.setBindGroup(2, this._getBindGroup(this.pipelines.transparent.getBindGroupLayout(2), [
                    { binding: 0, resource: { buffer: this.lightBuffer, offset: 0, size: 12 } }, // lightDirection
                    { binding: 1, resource: { buffer: this.lightBuffer, offset: 16, size: 12 } }  // ambientColor
                ]));
                // Render water (conceptual)
                // pass.setVertexBuffer(0, this.geometries.water.vertexBuffer);
                // pass.setIndexBuffer(this.geometries.water.indexBuffer, 'uint32');
                // pass.drawIndexed(this.geometries.water.indexCount);
            }
            commandEncoder.popDebugGroup(); // End Render Transparent Objects

            // Render Particles
            commandEncoder.pushDebugGroup('Render Particles');
            if (this.pipelines.particleRender && this.particleSystem.particleBuffer) {
                renderPass.setPipeline(this.pipelines.particleRender);
                renderPass.setBindGroup(0, this._getBindGroup(this.pipelines.particleRender.getBindGroupLayout(0), [
                    { binding: 2, resource: { buffer: this.uniformBuffer } } // Camera viewProjection
                ]));
                renderPass.setVertexBuffer(0, this.particleSystem.particleBuffer);
                renderPass.draw(this.particleSystem.particleCount);
            }
            commandEncoder.popDebugGroup(); // End Render Particles

            // Render Effects (e.g., explosions, lightning)
            commandEncoder.pushDebugGroup('Render Effects');
            if (this.pipelines.effects) {
                renderPass.setPipeline(this.pipelines.effects);
                // Bind groups for effects
                renderPass.setBindGroup(0, this._getBindGroup(this.pipelines.effects.getBindGroupLayout(0), [
                    { binding: 0, resource: { buffer: this.uniformBuffer } } // Camera MVP
                ]));
                // Render effects (conceptual)
                // pass.setVertexBuffer(0, this.geometries.effect.vertexBuffer);
                // pass.draw(this.geometries.effect.vertexCount);
            }
            commandEncoder.popDebugGroup(); // End Render Effects

            renderPass.end();
            commandEncoder.popDebugGroup(); // End Main Render Pass


            // Post-processing pass
            this.renderPostProcessing(commandEncoder, deltaTime);

            this.device.queue.submit([commandEncoder.finish()]);
        }

        renderPostProcessing(commandEncoder, deltaTime) {
            commandEncoder.pushDebugGroup('Post-Processing Pass');

            // Update post-process uniforms
            this.device.queue.writeBuffer(this.postProcessResolutionBuffer, 0, new Float32Array([this.canvas.width, this.canvas.height]));
            this.device.queue.writeBuffer(this.postProcessTimeBuffer, 0, new Float32Array([performance.now() / 1000]));


            const postPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: this.context.getCurrentTexture().createView(), // Render to canvas
                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
            });

            if (this.pipelines.postProcess) {
                postPass.setPipeline(this.pipelines.postProcess);
                postPass.setBindGroup(0, this._getBindGroup(this.pipelines.postProcess.getBindGroupLayout(0), [
                    { binding: 0, resource: this.renderTargetTextureView },
                    { binding: 1, resource: this.renderTargetSampler },
                    { binding: 2, resource: { buffer: this.postProcessResolutionBuffer } },
                    { binding: 3, resource: { buffer: this.postProcessTimeBuffer } }
                ]));
                postPass.draw(4); // Draw a full-screen quad (4 vertices for triangle strip)
            }

            postPass.end();
            commandEncoder.popDebugGroup(); // End Post-Processing Pass
        }
    }

    class ParticleSystem {
        constructor(device) {
            this.device = device;
            this.particleCount = 10000;
            this.computePipeline = null;
            this.particleBuffer = null;
            this.deltaTimeBuffer = null;
        }

        async init() {
            // Create buffer for compute shader
            this.particleBuffer = this.device.createBuffer({
                size: this.particleCount * (3 * 4 + 3 * 4 + 4 * 4 + 1 * 4), // position (vec3f, 12 bytes) + velocity (vec3f, 12 bytes) + color (vec4f, 16 bytes) + lifetime (f32, 4 bytes) = 44 bytes per particle
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
            });

            // Initialize particle data on CPU and copy to GPU
            const initialParticleData = new Float32Array(this.particleCount * (3 + 3 + 4 + 1)); // 11 floats per particle
            for (let i = 0; i < this.particleCount; ++i) {
                const offset = i * 11;
                initialParticleData[offset + 0] = (Math.random() - 0.5) * 10; // pos.x
                initialParticleData[offset + 1] = Math.random() * 5 + 5;     // pos.y
                initialParticleData[offset + 2] = (Math.random() - 0.5) * 10; // pos.z
                initialParticleData[offset + 3] = (Math.random() - 0.5) * 2; // vel.x
                initialParticleData[offset + 4] = Math.random() * 5 + 1;     // vel.y
                initialParticleData[offset + 5] = (Math.random() - 0.5) * 2; // vel.z
                initialParticleData[offset + 6] = Math.random(); // color.r
                initialParticleData[offset + 7] = Math.random(); // color.g
                initialParticleData[offset + 8] = Math.random(); // color.b
                initialParticleData[offset + 9] = 1.0; // color.a
                initialParticleData[offset + 10] = Math.random() * 5 + 1; // lifetime
            }
            this.device.queue.writeBuffer(this.particleBuffer, 0, initialParticleData);

            // Delta time uniform buffer for compute shader
            this.deltaTimeBuffer = this.device.createBuffer({
                size: 4, // sizeof(f32)
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Compute pipeline
            this.computePipeline = await this.device.createComputePipelineAsync({
                layout: 'auto',
                compute: {
                    module: this.device.createShaderModule({
                        code: particleComputeShaderWGSL
                    }),
                    entryPoint: 'simulateParticles'
                }
            });
        }

        update(deltaTime) {
            if (!this.computePipeline || !this.particleBuffer || !this.deltaTimeBuffer) return;

            const commandEncoder = this.device.createCommandEncoder();
            commandEncoder.pushDebugGroup('Particle Compute Pass');

            // Update deltaTime uniform buffer
            this.device.queue.writeBuffer(this.deltaTimeBuffer, 0, new Float32Array([deltaTime]));

            // Compute pass
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(this.computePipeline);
            computePass.setBindGroup(0, this._getParticleComputeBindGroup());
            computePass.dispatchWorkgroups(Math.ceil(this.particleCount / 64));
            computePass.end();

            this.device.queue.submit([commandEncoder.finish()]);
            commandEncoder.popDebugGroup(); // End Particle Compute Pass
        }

        _getParticleComputeBindGroup() {
            // This bind group is for compute shader, so it's not cached by WebGPURenderer's cache
            return this.device.createBindGroup({
                layout: this.computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: this.particleBuffer } },
                    { binding: 1, resource: { buffer: this.deltaTimeBuffer } }
                ]
            });
        }
    }

    class InstancedRenderer {
        constructor(device, meshName, maxInstances) {
            this.device = device;
            this.meshName = meshName;
            this.maxInstances = maxInstances;

            this.instanceBuffer = device.createBuffer({
                size: maxInstances * ((16 + 9 + 1) * 4), // Corrected: glMatrix.mat4(16 floats) + glMatrix.mat3(9 floats) + materialID(1 float) = 26 floats * 4 bytes/float = 104 bytes
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
            });

            this.instanceData = new Float32Array(maxInstances * (16 + 9 + 1)); // Corrected: For CPU side updates (26 floats)
            this.instanceCount = 0;
        }

        addInstance(transform, materialID) { // materialID is now passed directly
            if (this.instanceCount >= this.maxInstances) {
                console.warn("Max instances reached for InstancedRenderer:", this.meshName);
                return;
            }
            const offset = this.instanceCount * (16 + 9 + 1); // Corrected offset calculation

            // Model Matrix (glMatrix.mat4)
            this.instanceData.set(transform.matrix, offset);

            // Normal Matrix (glMatrix.mat3) - derived from model matrix
            // glMatrix.mat3.normalFromMat4: Calcola la matrice normale (matrice 3x3 per la trasformazione delle normali) da una matrice modello 4x4.
            glMatrix.mat3.normalFromMat4(tempMat3, transform.matrix); // Usa tempMat3 pre-allocato per il calcolo della matrice normale
            this.instanceData.set(tempMat3, offset + 16); // 16 floats for mat4

            // Material ID (u32)
            this.instanceData[offset + 16 + 9] = materialID; // Store materialID at the correct offset after mat4 (16) and mat3 (9)

            this.instanceCount++;
        }

        render(renderPass) {
            if (this.instanceCount === 0) return;

            // Update instance buffer on GPU
            this.device.queue.writeBuffer(
                this.instanceBuffer,
                0,
                this.instanceData.buffer,
                0,
                this.instanceCount * ((16 + 9 + 1) * 4) // Corrected size in bytes
            );

            const mesh = gameEngine.webGPURenderer.geometries[this.meshName];
            if (!mesh) {
                console.warn(`Mesh not found for instanced rendering: ${this.meshName}`);
                return;
            }

            renderPass.setVertexBuffer(0, mesh.vertexBuffer);
            renderPass.setIndexBuffer(mesh.indexBuffer, 'uint32');
            renderPass.setVertexBuffer(1, this.instanceBuffer); // Bind the instance buffer

            renderPass.drawIndexed(mesh.indexCount, this.instanceCount, 0, 0, 0);
            this.instanceCount = 0; // Reset for next frame
        }
    }

    class GameEngine {
        constructor() {
            this.webGPURenderer = new WebGPURenderer();
            this.lastTime = 0;
            this.camera = {
                position: [0, 1.6, 0], // Camera at player position
                target: [0, 1.6, -1],   // Looking forward from player
                up: [0, 1, 0],       // Up vector
                fov: 60,
                near: 0.1,
                far: 1000,
                yaw: 0,   // Rotazione orizzontale
                pitch: 0, // Rotazione verticale
                sensitivity: 0.002 // Sensibilità del mouse/touch
            };
            // Pre-allocate glMatrix objects for camera calculations
            // These will be initialized in the init() method to ensure glMatrix is loaded.
            this.cameraProjectionMatrix = null;
            this.cameraViewMatrix = null;
            this.cameraViewProjectionMatrix = null;
            this.cameraDirection = null;
            this.cameraRight = null;
        }

        async init() {
            await this.webGPURenderer.init();
            await physicsSystem.init(); // Initialize the physics system (now JS fallback)

            // Initialize glMatrix temporary variables here to ensure glMatrix is loaded
            tempMat4 = glMatrix.mat4.create();
            tempMat3 = glMatrix.mat3.create();
            tempVec3_1 = glMatrix.vec3.create();
            tempVec3_2 = glMatrix.vec3.create();

            // Initialize camera matrices here as well
            this.cameraProjectionMatrix = glMatrix.mat4.create(); // glMatrix.mat4.create: Crea una nuova matrice 4x4.
            this.cameraViewMatrix = glMatrix.mat4.create(); // glMatrix.mat4.create: Crea una nuova matrice 4x4.
            this.cameraViewProjectionMatrix = glMatrix.mat4.create(); // glMatrix.mat4.create: Crea una nuova matrice 4x4.
            this.cameraDirection = glMatrix.vec3.create(); // glMatrix.vec3.create: Crea un nuovo vettore 3D.
            this.cameraRight = glMatrix.vec3.create(); // glMatrix.vec3.create: Crea un nuovo vettore 3D.

            // Initialize game state with transforms (these will be updated by game logic)
            // Moved glMatrix.mat4.create() calls here to ensure glMatrix is defined
            gameState.delorean.transform.matrix = glMatrix.mat4.create(); // glMatrix.mat4.create: Crea una nuova matrice 4x4 per la trasformazione della DeLorean.
            // glMatrix.mat4.translate: Applica una traslazione a una matrice.
            glMatrix.mat4.translate(gameState.delorean.transform.matrix, gameState.delorean.transform.matrix, [deloreanPosition.x, deloreanPosition.y, deloreanPosition.z]);
            // glMatrix.mat4.scale: Applica una scalatura a una matrice.
            glMatrix.mat4.scale(gameState.delorean.transform.matrix, gameState.delorean.transform.matrix, [5, 5, 5]); // Scale DeLorean

            // Initial setup for player position for rendering (camera will follow)
            playerPosition.transform.matrix = glMatrix.mat4.create(); // glMatrix.mat4.create: Crea una nuova matrice 4x4 per la trasformazione del giocatore.
            // glMatrix.mat4.translate: Applica una traslazione a una matrice.
            glMatrix.mat4.translate(playerPosition.transform.matrix, playerPosition.transform.matrix, [playerPosition.x, playerPosition.y, playerPosition.z]);
        }

        gameLoop(timestamp) {
            const deltaTime = (timestamp - this.lastTime) / 1000;
            this.lastTime = timestamp;

            if (gameState.gameOver || gameState.isCraftingMenuOpen) {
                requestAnimationFrame(this.gameLoop.bind(this));
                return;
            }

            // Update game logic (player movement, collisions, etc.)
            updateGame(deltaTime);

            // Update camera position and target based on player/DeLorean and camera rotation
            if (gameState.inDeLorean) {
                // Camera follows DeLorean
                this.camera.position = [deloreanPosition.x, deloreanPosition.y + 5, deloreanPosition.z + 10]; // Behind DeLorean
                // Target based on DeLorean's forward direction
                // glMatrix.vec3.set: Imposta i componenti di un vettore 3D.
                glMatrix.vec3.set(tempVec3_1, // Usa tempVec3_1 pre-allocato
                    Math.sin(gameState.deloreanPlayer.rotation),
                    0,
                    -Math.cos(gameState.deloreanPlayer.rotation)
                );
                // glMatrix.vec3.add: Aggiunge due vettori 3D.
                glMatrix.vec3.add(this.camera.target, this.camera.position, tempVec3_1);

            } else {
                // Camera at player position (first person)
                this.camera.position = [playerPosition.x, playerPosition.y, playerPosition.z];

                // Calculate target based on yaw and pitch
                // glMatrix.vec3.set: Imposta i componenti di un vettore 3D.
                glMatrix.vec3.set(this.cameraDirection, // Usa this.cameraDirection pre-allocato
                    Math.cos(this.camera.yaw) * Math.cos(this.camera.pitch),
                    Math.sin(this.camera.pitch),
                    Math.sin(this.camera.yaw) * Math.cos(this.camera.pitch)
                );
                // glMatrix.vec3.add: Aggiunge due vettori 3D.
                glMatrix.vec3.add(this.camera.target, this.camera.position, this.cameraDirection);
            }

            // Update particles (compute shader)
            this.webGPURenderer.particleSystem.update(deltaTime);

            // Prepare rendering scene for instanced renderers
            this._prepareScene();

            // Render the scene using WebGPURenderer
            this.webGPURenderer.render(this._getSceneData(), this.camera, deltaTime); // Pass deltaTime for post-processing

            stats.update(); // Update Stats.js
            requestAnimationFrame(this.gameLoop.bind(this));
        }

        _prepareScene() {
            // Clear instancer counts for the new frame
            this.webGPURenderer.zombieInstancer.instanceCount = 0;
            this.webGPURenderer.deloreanInstancer.instanceCount = 0;

            // Add game objects to instanced renderers
            for (const zombie of gameState.zombies) {
                const zombieTransform = tempMat4; // Usa tempMat4 pre-allocato
                // glMatrix.mat4.identity: Resetta una matrice 4x4 alla matrice identità.
                glMatrix.mat4.identity(zombieTransform); // Reset
                // glMatrix.mat4.translate: Applica una traslazione a una matrice.
                glMatrix.mat4.translate(zombieTransform, zombieTransform, [zombie.x, zombie.y, zombie.z]);
                // glMatrix.mat4.scale: Applica una scalatura a una matrice.
                glMatrix.mat4.scale(zombieTransform, zombieTransform, [0.5, 0.5, 0.5]); // Example scale for zombies
                this.webGPURenderer.zombieInstancer.addInstance({ matrix: zombieTransform }, zombie.type); // Pass material ID
            }

            // Add DeLorean
            const deloreanTransform = tempMat4; // Usa tempMat4 pre-allocato
            // glMatrix.mat4.identity: Resetta una matrice 4x4 alla matrice identità.
            glMatrix.mat4.identity(deloreanTransform); // Reset
            // glMatrix.mat4.translate: Applica una traslazione a una matrice.
            glMatrix.mat4.translate(deloreanTransform, deloreanTransform, [deloreanPosition.x, deloreanPosition.y, deloreanPosition.z]);
            // glMatrix.mat4.rotateY: Ruota una matrice 4x4 attorno all'asse Y.
            glMatrix.mat4.rotateY(deloreanTransform, deloreanTransform, gameState.deloreanPlayer.rotation);
            // glMatrix.mat4.scale: Applica una scalatura a una matrice.
            glMatrix.mat4.scale(deloreanTransform, deloreanTransform, [5, 5, 5]); // Scale DeLorean
            this.webGPURenderer.deloreanInstancer.addInstance({ matrix: deloreanTransform }, 2); // Material ID 2 for DeLorean
        }

        _getSceneData() {
            // This would return a structured scene graph or list of renderable objects
            // For now, it's conceptual as instanced renderers handle the actual drawing.
            return {
                opaqueObjects: [], // Managed by instanced renderers
                transparentObjects: [],
                effects: []
            };
        }
    }

    // Global game engine instance
    const gameEngine = new GameEngine();

    /**
     * Conceptual function to get optimal rendering resolution based on FPS.
     * @returns {Array<number>} [width, height]
     */
    function getOptimalResolution() {
        // This function would typically get the current FPS from a more robust profiling system
        // For this example, we'll use a dummy FPS or assume a base resolution.
        const currentFPS = stats ? stats.fps : 60; // Assuming stats.js is providing FPS

        const baseWidth = window.innerWidth;
        const baseHeight = window.innerHeight;

        if (currentFPS < 30 && currentFPS > 0) { // Avoid division by zero
            // Scale down if FPS is low
            return [Math.floor(baseWidth * 0.7), Math.floor(baseHeight * 0.7)];
        }
        return [baseWidth, baseHeight];
    }


    // Funzione principale di inizializzazione
    async function initGame() {
      try {
        // Inizializza Stats.js
        stats = new Stats();
        document.body.appendChild(stats.dom);

        // Initialize the full game engine
        await gameEngine.init();

        // Initialize radar canvas context
        radarCanvas = document.getElementById('radarCanvas');
        radarCanvas.width = radarSize;
        radarCanvas.height = radarSize;
        radarCtx = radarCanvas.getContext('2d');

        // Nascondi schermata di caricamento
        document.getElementById('loadingScreen').style.display = 'none';

        // Avvia il gioco
        startGame();
      } catch (error) {
        console.error("Errore durante l'inizializzazione:", error);
        document.getElementById('loadingScreen').innerHTML = `
          <h1>ERRORE DI INIZIALIZZAZIONE</h1>
          <p>${error.message}</p>
          <p>Il tuo browser potrebbe non supportare WebGPU o WebAssembly</p>
        `;
      }
    }

    // Funzione di avvio del gioco
    function startGame() {
      isTouchDevice = ('ontouchstart' in window) ||
                      (navigator.maxTouchPoints > 0) ||
                      (navigator.msMaxTouchPoints > 0);

      // Inizializzazione del gioco (senza rendering 3D di Three.js)
      createZombies(gameState.zombiesTotal); // Popola l'array degli zombie per WASM
      setupEventListeners();
      updateTimeOfDay(currentTime);
      updateUIVisibility();
      updateUI(); // Aggiorna l'UI iniziale

      gameState.powerUpSpawnTimer = gameState.powerUpSpawnInterval;
      gameState.lightningStrikeRandomTimer = Math.random() * (gameState.lightningStrikeRandomIntervalMax - gameState.lightningStrikeRandomIntervalMin) + gameState.lightningStrikeRandomIntervalMin;

      // Avvia il loop di gioco
      gameEngine.gameLoop(performance.now()); // Start the game loop from GameEngine
      showMessage("MISSIONE INIZIATA!", 2000);
    }

    // Funzione di aggiornamento della logica del gioco (non rendering 3D)
    function updateGame(delta) {
        currentTime += delta * (24 / (120 * 60)); // Simulate time passing
        const currentHour = currentTime % 24;
        updateTimeOfDay(currentHour);

        const currentDay = Math.floor(currentTime / 24) + 1;
        if (currentDay !== gameState.gameDay) {
            gameState.gameDay = currentDay;
            updateWeatherLogic(gameState.gameDay);
        }

        if (gameState.weatherTimer > 0 && !gameState.isCloudStormActive) {
            gameState.weatherTimer -= delta;
            if (gameState.weatherTimer <= 0) {
                applyWeather('clear');
                showMessage("IL TEMPO E' MIGLIORATO!", 2000);
                clearObjective();
            }
        }

        if (gameState.currentWeather === 'thunderstorm' && !gameState.isCloudStormActive) {
            gameState.lightningFlickerTimer -= delta;
            if (gameState.lightningFlickerTimer <= 0) {
                if (!gameState.isLightningActive) {
                    // Simulate lightning visual effect (UI only)
                    document.body.style.backgroundColor = 'rgba(200,200,255,0.5)';
                    gameState.isLightningActive = true;
                    gameState.lightningFlickerTimer = gameState.lightningDuration;
                } else {
                    document.body.style.backgroundColor = ''; // Reset
                    gameState.isLightningActive = false;
                    gameState.lightningFlickerTimer = Math.random() * gameState.lightningInterval;
                }
            }
        } else if (!gameState.isCloudStormActive) {
            gameState.isLightningActive = false;
        }

        triggerRandomLightning(delta);

        if (gameState.isCloudStormActive) {
            gameState.cloudStormTimer -= delta;
            gameState.cloudStormLightningTimer -= delta;

            if (gameState.cloudStormTimer > gameState.triggeredRainDuration - gameState.atmosphericExplosionDuration) {
                if (gameState.cloudStormLightningTimer <= 0) {
                    // Simulate cloud storm lightning (UI only)
                    document.body.style.backgroundColor = 'rgba(100,100,150,0.7)';
                    setTimeout(() => {
                        document.body.style.backgroundColor = '';
                    }, 100);
                    gameState.cloudStormLightningTimer = 0.1 + Math.random() * 0.2;
                }
            } else {
                document.body.style.backgroundColor = '';
            }
        }

        // --- Physics Update using JS Fallback ---
        physicsSystem.update(
            delta,
            playerPosition,
            gameState.inDeLorean,
            deloreanPosition
        );

        // Simplified player movement (still in JS)
        let currentSpeed = (movement.sprint ? movement.playerSpeed * 1.8 : movement.playerSpeed) * (gameState.isDistorted ? 0.5 : 1.0) * (gameState.isSpeedBoostActive ? gameState.speedBoostMultiplier : 1.0);
        const moveDistance = currentSpeed * delta;

        // Update player's position based on movement and camera direction
        // glMatrix.vec3.copy: Copia i componenti di un vettore 3D in un altro.
        glMatrix.vec3.copy(tempVec3_1, gameEngine.cameraDirection); // Usa tempVec3_1 pre-allocato
        tempVec3_1[1] = 0; // Keep movement on the horizontal plane
        // glMatrix.vec3.normalize: Normalizza un vettore 3D.
        glMatrix.vec3.normalize(tempVec3_1, tempVec3_1);

        // glMatrix.vec3.cross: Calcola il prodotto vettoriale di due vettori 3D.
        glMatrix.vec3.cross(tempVec3_2, tempVec3_1, gameEngine.camera.up); // Usa tempVec3_2 pre-allocato
        // glMatrix.vec3.normalize: Normalizza un vettore 3D.
        glMatrix.vec3.normalize(tempVec3_2, tempVec3_2);

        if (movement.forward) {
            playerPosition.x += tempVec3_1[0] * moveDistance;
            playerPosition.z += tempVec3_1[2] * moveDistance;
        }
        if (movement.backward) {
            playerPosition.x -= tempVec3_1[0] * moveDistance;
            playerPosition.z -= tempVec3_1[2] * moveDistance;
        }
        if (movement.left) {
            playerPosition.x -= tempVec3_2[0] * moveDistance;
            playerPosition.z -= tempVec3_2[2] * moveDistance;
        }
        if (movement.right) {
            playerPosition.x += tempVec3_2[0] * moveDistance;
            playerPosition.z += tempVec3_2[2] * moveDistance;
        }


        // Update player's transform for rendering (camera will follow this)
        // glMatrix.mat4.identity: Resetta una matrice 4x4 alla matrice identità.
        glMatrix.mat4.identity(playerPosition.transform.matrix);
        // glMatrix.mat4.translate: Applica una traslazione a una matrice.
        glMatrix.mat4.translate(playerPosition.transform.matrix, playerPosition.transform.matrix, [playerPosition.x, playerPosition.y, playerPosition.z]);


        // Simplified DeLorean movement (still in JS)
        if (gameState.inDeLorean) {
            updateDeLoreanPhysics(delta);
            deloreanPosition.x += Math.sin(gameState.deloreanPlayer.rotation) * gameState.deloreanPlayer.speed * delta * 5;
            deloreanPosition.z -= Math.cos(gameState.deloreanPlayer.rotation) * gameState.deloreanPlayer.speed * delta * 5;
            updateDeLoreanDashboardUI();
        }

        // Collision checks (still in JS, operating on updated gameState.zombies/projectiles)
        checkPowerUpCollisions();
        // Check zombie-player/delorean collisions and apply damage
        gameState.zombies.forEach(z => {
            if (!gameState.inDeLorean && Math.abs(z.x - playerPosition.x) < 2 && Math.abs(z.z - playerPosition.z) < 2) {
                gameState.playerHealth = Math.max(0, gameState.playerHealth - 1); // Example damage
                showHitEffect();
                updateUI();
                if (gameState.playerHealth <= 0) gameOver();
            } else if (gameState.inDeLorean && Math.abs(z.x - deloreanPosition.x) < 5 && Math.abs(z.z - deloreanPosition.z) < 5) {
                // DeLorean hit by zombie
                gameState.deloreanFuel = Math.max(0, gameState.deloreanFuel - 0.5); // Example fuel loss
                updateDeLoreanDashboardUI();
                if (gameState.deloreanFuel <= 0 && !gameState.deloreanIsVulnerable) {
                    gameState.deloreanIsVulnerable = true;
                    gameState.deloreanVulnerabilityTimer = gameState.deloreanVulnerabilityDuration;
                    showMessage("BENZINA FINITA! LA DELOREAN È VULNERABILE!", 3000);
                }
            }
        });

        // Simplified projectile-zombie/object collisions
        // Filter projectiles that hit zombies or are out of bounds
        // Now using pooling: iterate over active projectiles and deactivate on hit/out of bounds
        gameState.projectiles.forEach(p => {
            if (!p.active) return;

            let hit = false;
            gameState.zombies.forEach(z => {
                if (Math.abs(p.x - z.x) < 1 && Math.abs(p.z - z.z) < 1) { // Simple 2D distance check
                    z.health -= p.damage;
                    if (z.health <= 0) zombieHit(z, p.damage);
                    hit = true;
                }
            });
            if (hit) {
                p.active = false; // Deactivate projectile on hit
            }
        });


        gameState.powerUpSpawnTimer -= delta;
        if (gameState.powerUpSpawnTimer <= 0) {
            spawnPowerUp();
            gameState.powerUpSpawnTimer = gameState.powerUpSpawnInterval;
        }

        gameState.rockSpawnTimer -= delta;
        if (gameState.rockSpawnTimer <= 0 && gameState.destructibleRocks.length < gameState.maxDestructibleRocks) {
            createDestructibleRock();
            gameState.rockSpawnTimer = gameState.rockSpawnInterval;
        }

        if (gameState.isDamageBoostActive) {
            gameState.damageBoostTimer -= delta;
            if (gameState.damageBoostTimer <= 0) {
                gameState.isDamageBoostActive = false;
                showMessage("DANNO NORMALE", 1500);
            }
        }

        if (gameState.isSpeedBoostActive) {
            gameState.speedBoostTimer -= delta;
            if (gameState.speedBoostTimer <= 0) {
                gameState.isSpeedBoostActive = false;
                showMessage("VELOCITÀ AUMENTATA!", 1500);
            }
        }

        if (gameState.isDistorted) {
            gameState.distortionTimer -= delta;
            if (distortionOverlay) {
                distortionOverlay.classList.remove('active');
                setTimeout(() => {
                    distortionOverlay.style.display = 'none';
                }, 200);
            }
            if (gameState.distortionTimer <= 0) {
                gameState.isDistorted = false;
                showMessage("PERCEZIONE NORMALE", 1000);
            }
        }

        // Simplified crosshair targeting (no raycasting)
        crosshair.classList.remove('target-locked'); // Always remove for now

        updateObjective(delta);
        drawRadar();
    }

    // --- Placeholder/Stub Functions (from previous Three.js version) ---
    function createEnvironment() { /* Concettuale: caricherebbe gli asset WebGPU */ }
    function generateTrees(count) { return []; }
    function generateStaticRocks(count) { return []; }
    function createDestructibleRock() {
        // Aggiunge una roccia concettuale a gameState.destructibleRocks
        gameState.destructibleRocks.push({ x: (Math.random() - 0.5) * 80, y: 0, z: (Math.random() - 0.5) * 80, health: 50 });
        updateAllInteractableMeshes(); // Aggiorna i buffer WebGPU per la visualizzazione
    }
    function createMountains() { return []; }
    function addClouds(count) { return []; }
    function createNavigatorSpaceship() { /* Concettuale */ }
    function createRainParticles() { /* Concettuale */ }
    function createSnowParticles() { /* Concettuale */ }
    function createSandParticles() { /* Concettuale */ }
    function updateParticles(particles, speed, delta) { /* Concettuale */ }
    function applyWeather(type) { /* Concettuale */ }
    function createWeapons() { /* Concettuale */ }
    function switchWeapon() {
        const currentWeaponData = gameState.weapons[gameState.currentWeapon];
        if (gameState.currentWeapon === 'rifle') {
            gameState.currentWeapon = 'shotgun';
        } else {
            gameState.currentWeapon = 'rifle';
        }
        updateUI();
        showMessage(`ARMA: ${gameState.weapons[gameState.currentWeapon].name}`, 1000);
    }
    function switchDeLoreanWeapon() {
        if (gameState.currentDeLoreanWeapon === 'machineGun') {
            gameState.currentDeLoreanWeapon = 'cannon';
        } else {
            gameState.currentDeLoreanWeapon = 'machineGun';
        }
        updateDeLoreanDashboardUI();
        showMessage(`ARMA: ${gameState.deloreanWeapons[gameState.currentDeLoreanWeapon].name}`, 1000);
    }
    function spawnPowerUp(position = null, type = null) {
        const randomType = type || (Math.random() < 0.3 ? 'delorean_fuel' : (Math.random() < 0.6 ? 'health' : (Math.random() < 0.8 ? 'ammo' : 'speed_boost')));
        const spawnPos = position || { x: (Math.random() - 0.5) * 80, y: 0, z: (Math.random() - 0.5) * 80 };
        gameState.powerUps.push({ position: spawnPos, type: randomType, collected: false });
        updateAllInteractableMeshes(); // Aggiorna i buffer WebGPU per la visualizzazione
    }
    function createZombies(count, isLightningZombie = false, position = null, isRockSpawned = false, isKamikazeBunny = false) {
        for (let i = 0; i < count; i++) {
            let health;
            let originalSpeed;
            let zombieType; // Will map to materialID

            if (isKamikazeBunny) {
                zombieType = 3; // Material ID for Kamikaze Bunny
                originalSpeed = 4.0;
                health = 10;
            } else if (isLightningZombie) {
                zombieType = 1; // Material ID for Lightning Zombie
                originalSpeed = 1.2 * 2.5;
                health = 500;
            } else {
                zombieType = 0; // Material ID for Normal Zombie
                originalSpeed = 1.2;
                health = 2 + gameState.level;
            }

            const spawnX = position ? position.x + (Math.random() - 0.5) * 2 : (Math.random() - 0.5) * 80;
            const spawnZ = position ? position.z + (Math.random() - 0.5) * 2 : (Math.random() - 0.5) * 80;

            const newZombie = {
                x: spawnX, y: 0.75, z: spawnZ,
                vx: 0, vy: 0, vz: 0,
                health: health,
                maxHealth: health,
                originalSpeed: originalSpeed,
                attackCooldown: 0,
                chasingPlayer: false,
                chaseTimer: 0,
                isKamikazeBunny: isKamikazeBunny,
                isLightningZombie: isLightningZombie,
                isRockSpawned: isRockSpawned,
                explosionRadius: isKamikazeBunny ? 5 : 0,
                explosionDamage: isKamikazeBunny ? 50 : 0,
                canShootElectricity: isRockSpawned,
                electricityCooldown: isRockSpawned ? (3 + Math.random() * 2) : 0,
                electricityDamage: isRockSpawned ? 15 : 0,
                type: zombieType // Pass material ID to JS zombie object
            };
            physicsSystem.addZombie(newZombie); // Add to physics system, which now directly modifies gameState.zombies
        }
        updateZombieCounter();
        updateAllInteractableMeshes(); // Aggiorna i buffer WebGPU per la visualizzazione
    }
    function updateAllInteractableMeshes() { /* Concettuale: aggiornerebbe i buffer WebGPU per tutti gli oggetti interattivi */ }
    function animateZombies(delta) { /* Gestito dalla logica di fallback JS della fisica */ }
    function addStaticDecorations(count) { /* Concettuale */ }
    function createLighthouse() {
        gameState.lighthouseMesh = { position: { x: 150, y: 0, z: -150 }, isActive: false };
        updateAllInteractableMeshes();
    }
    function toggleLighthouse() {
        if (gameState.lighthouseMesh) {
            gameState.lighthouseMesh.isActive = !gameState.lighthouseMesh.isActive;
            showMessage(gameState.lighthouseMesh.isActive ? "FARO ATTIVATO!" : "FARO DISATTIVATO!", 2000);
            if (gameState.lighthouseMesh.isActive) {
                // Clear nearby zombies (simplified)
                gameState.zombies = gameState.zombies.filter(z =>
                    Math.abs(z.x - gameState.lighthouseMesh.position.x) > 100 ||
                    Math.abs(z.z - gameState.lighthouseMesh.position.z) > 100
                );
            }
        }
    }
    function setupEventListeners() {
        async function startGameHandler(e) {
            e.preventDefault();
            startScreen.style.display = 'none';
            // No PointerLockControls in WebGPU version, camera movement handled by mouse/touch events
            showMessage("Tocca l'area di gioco per muovere la visuale.", 3000);
            startGame(); // Call startGame after UI setup
        }

        async function restartGameHandler(e) {
            e.preventDefault();
            gameOverScreen.style.display = 'none';
            resetGame();
            showMessage("Tocca l'area di gioco per muovere la visuale.", 3000);
            startGame(); // Call startGame after UI setup
        }

        startButton.addEventListener('click', startGameHandler);
        startButton.addEventListener('touchstart', startGameHandler, { passive: false });

        restartButton.addEventListener('click', restartGameHandler);
        restartButton.addEventListener('touchstart', restartGameHandler, { passive: false });

        // Simplified touch/mouse look (no PointerLockControls)
        let isLookingWithTouch = false;
        let lastTouchX_camera = 0;
        let lastTouchY_camera = 0;
        const touchLookSensitivity = 0.005; // Placeholder, not used in this conceptual camera

        document.querySelector('canvas').addEventListener('mousedown', (e) => {
            if (startScreen.style.display === 'none' && !gameState.isCraftingMenuOpen) {
                isLookingWithTouch = true;
                lastTouchX_camera = e.clientX;
                lastTouchY_camera = e.clientY;
            }
        });
        document.querySelector('canvas').addEventListener('mousemove', (e) => {
            if (isLookingWithTouch) {
                const dx = e.clientX - lastTouchX_camera;
                const dy = e.clientY - lastTouchY_camera;

                // Update camera yaw and pitch
                gameEngine.camera.yaw -= dx * gameEngine.camera.sensitivity;
                gameEngine.camera.pitch += dy * gameEngine.camera.sensitivity;

                // Clamp pitch to avoid flipping
                gameEngine.camera.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, gameEngine.camera.pitch));

                lastTouchX_camera = e.clientX;
                lastTouchY_camera = e.clientY;
            }
        });
        document.querySelector('canvas').addEventListener('mouseup', () => {
            isLookingWithTouch = false;
        });

        document.querySelector('canvas').addEventListener('touchstart', (e) => {
            if (startScreen.style.display === 'none' && !e.target.closest('.touch-button') && e.target !== joystickContainer && e.target !== joystickHandle) {
                e.preventDefault();
                isLookingWithTouch = true;
                lastTouchX_camera = e.touches[0].clientX;
                lastTouchY_camera = e.touches[0].clientY;
            }
        }, { passive: false });

        document.querySelector('canvas').addEventListener('touchmove', (e) => {
            if (isLookingWithTouch) {
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - lastTouchX_camera;
                const dy = touch.clientY - lastTouchY_camera;

                // Update camera yaw and pitch
                gameEngine.camera.yaw -= dx * gameEngine.camera.sensitivity * 2; // Increased sensitivity for touch
                gameEngine.camera.pitch += dy * gameEngine.camera.sensitivity * 2;

                // Clamp pitch to avoid flipping
                gameEngine.camera.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, gameEngine.camera.pitch));

                lastTouchX_camera = touch.clientX;
                lastTouchY_camera = touch.clientY;
            }
        }, { passive: false });

        document.querySelector('canvas').addEventListener('touchend', () => {
            isLookingWithTouch = false;
        });

        document.addEventListener('keydown', (e) => {
            keys[e.keyCode] = true;
            if (gameState.gameOver || gameState.isCraftingMenuOpen) return;
            // Simplified key handling for movement (no Three.js controls)
            if (e.code === 'KeyW') movement.forward = true;
            if (e.code === 'KeyA') movement.left = true;
            if (e.code === 'KeyS') movement.backward = true;
            if (e.code === 'KeyD') movement.right = true;
            if (e.code === 'ShiftLeft') movement.sprint = true;
            if (e.code === 'Space') {
                // Simplified jump
                playerPosition.y += 0.5; // Instant jump for demo
                setTimeout(() => playerPosition.y = 1.6, 200); // Fall back
            }
            if (e.code === 'KeyR') reload();
            if (e.code === 'KeyN') toggleNightVision();
            if (e.code === 'KeyQ') switchWeapon();
            if (e.code === 'KeyE') {
                if (gameState.currentObjective === 'activate_lighthouse' && gameState.lighthouseMesh && Math.abs(playerPosition.x - gameState.lighthouseMesh.position.x) < 15) {
                    toggleLighthouse();
                } else {
                    checkDeLoreanProximityAndEnter();
                }
            }
            if (e.code === 'KeyC') toggleCraftingMenu();

            // DeLorean keys (conceptual)
            if (gameState.inDeLorean) {
                if (e.code === 'KeyL') toggleDeLoreanHeadlights();
                if (e.code === 'KeyF') shootDeLoreanMachineGun();
                if (e.code === 'KeyG') shootDeLoreanCannon();
                if (e.code === 'KeyE') exitDeLorean();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.keyCode] = false;
            if (gameState.gameOver || gameState.isCraftingMenuOpen) return;
            if (e.code === 'KeyW') movement.forward = false;
            if (e.code === 'KeyA') movement.left = false;
            if (e.code === 'KeyS') movement.backward = false;
            if (e.code === 'KeyD') movement.right = false;
            if (e.code === 'ShiftLeft') movement.sprint = false;
        });

        document.addEventListener('mousedown', (e) => {
            if (gameState.gameOver || gameState.isCraftingMenuOpen || gameState.inDeLorean) return;
            if (e.button !== 0) return;
            shoot();
        });

        joystickContainer.addEventListener('touchstart', onJoystickTouchStart, { passive: false });
        joystickContainer.addEventListener('touchmove', onJoystickTouchMove, { passive: false });
        joystickContainer.addEventListener('touchend', onJoystickTouchEnd);
        joystickContainer.addEventListener('touchcancel', onJoystickTouchEnd);

        jumpButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.inDeLorean) {
                playerPosition.y += 0.5; // Instant jump for demo
                setTimeout(() => playerPosition.y = 1.6, 200); // Fall back
            }
        }, { passive: false });
        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.inDeLorean) shoot();
        }, { passive: false });
        reloadButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.inDeLorean) reload();
        }, { passive: false });
        nightVisionButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleNightVision();
        }, { passive: false });
        switchWeaponButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.inDeLorean) switchWeapon();
        }, { passive: false });
        craftingButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleCraftingMenu();
        }, { passive: false });

        enterExitDeLoreanButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.inDeLorean) {
                exitDeLorean();
            } else {
                checkDeLoreanProximityAndEnter();
            }
        }, { passive: false });
        headlightsButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.inDeLorean) toggleDeLoreanHeadlights();
        }, { passive: false });
        deloreanMachineGunButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.inDeLorean) shootDeLoreanMachineGun();
        }, { passive: false });
        deloreanCannonButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.inDeLorean) shootDeLoreanCannon();
        }, { passive: false });

        closeCraftingButton.addEventListener('click', toggleCraftingMenu);
        craftRifleAmmoButton.addEventListener('click', () => craftAmmo('rifle'));
        craftShotgunAmmoButton.addEventListener('click', () => craftAmmo('shotgun'));

        window.addEventListener('resize', () => {
            const canvas = document.querySelector('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateUIVisibility();
        });
    }

    function onJoystickTouchStart(event) {
        event.preventDefault();
        movement.joystickActive = true;
        const touch = event.touches[0];
        const rect = joystickContainer.getBoundingClientRect();
        movement.joystickStart.x = rect.left + rect.width / 2;
        movement.joystickStart.y = rect.top + rect.height / 2;

        joystickHandle.style.transform = `translate(${touch.clientX - movement.joystickStart.x}px, ${touch.clientY - movement.joystickStart.y}px)`;
    }

    function onJoystickTouchMove(event) {
        event.preventDefault();
        if (!movement.joystickActive) return;

        const touch = event.touches[0];
        let dx = touch.clientX - movement.joystickStart.x;
        let dy = touch.clientY - movement.joystickStart.y;

        const distance = Math.sqrt(dx * dx + dy * dy);

        const sprintThreshold = movement.joystickRadius * movement.joystickSprintThresholdRatio;
        if (distance > sprintThreshold) {
            movement.sprint = true;
            joystickContainer.classList.add('sprint-active');
        } else {
            movement.sprint = false;
            joystickContainer.classList.remove('sprint-active');
        }

        if (distance > movement.joystickRadius) {
            dx *= movement.joystickRadius / distance;
            dy *= movement.joystickRadius / distance;
        }

        joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;

        if (gameState.inDeLorean) {
            // Simulate DeLorean movement with joystick
            // This is a very simplified mapping
            if (dy < -movement.joystickRadius * 0.2) gameState.deloreanPlayer.speed = Math.min(1.0, gameState.deloreanPlayer.speed + 0.05);
            else if (dy > movement.joystickRadius * 0.2) gameState.deloreanPlayer.speed = Math.max(-0.5, gameState.deloreanPlayer.speed - 0.05);
            else gameState.deloreanPlayer.speed *= 0.9; // Decelerate

            if (dx < -movement.joystickRadius * 0.2) gameState.deloreanPlayer.rotation -= 0.05;
            else if (dx > movement.joystickRadius * 0.2) gameState.deloreanPlayer.rotation += 0.05;
        } else {
            movement.forward = dy < -movement.joystickRadius * 0.2;
            movement.backward = dy > movement.joystickRadius * 0.2;
            movement.left = dx < -movement.joystickRadius * 0.2;
            movement.right = dx > movement.joystickRadius * 0.2;
        }
    }

    function onJoystickTouchEnd(event) {
        if (!movement.joystickActive) return;

        movement.joystickActive = false;
        joystickHandle.style.transform = 'translate(0, 0)';
        movement.forward = false;
        movement.backward = false;
        movement.left = false;
        movement.right = false;
        movement.sprint = false;
        joystickContainer.classList.remove('sprint-active');
        // Reset DeLorean speed/rotation when joystick released
        gameState.deloreanPlayer.speed = 0;
        // gameState.deloreanPlayer.rotation = 0; // Don't reset rotation, maintain last direction
    }

    function updateTimeOfDay(time) {
        const hour = Math.floor(time);
        const minute = Math.floor((time - hour) * 60);
        const ampm = hour >= 12 ? 'PM' : 'AM';
        const displayHour = hour % 12 || 12;

        timeDisplayTime.textContent = `${displayHour}:${minute.toString().padStart(2, '0')} ${ampm}`;
        timeDisplayLabel.textContent = (time >= 6 && time < 18) ? 'GIORNO SOLEGGIATO' : 'NOTTE';
    }

    function toggleNightVision() {
      gameState.nightVision = !gameState.nightVision;
      nightVisionOverlay.style.display = gameState.nightVision ? 'block' : 'none';
    }

    function toggleDeLoreanHeadlights() {
        // Conceptual: would control WebGPU light uniforms
        // For now, it's just a message and a state toggle (not visually implemented)
        gameState.deloreanWeapons.machineGun.muzzleFlashLight = !gameState.deloreanWeapons.machineGun.muzzleFlashLight; // Reusing this for headlights state
        showMessage("FARI DeLorean: " + (gameState.deloreanWeapons.machineGun.muzzleFlashLight ? "ACCESI" : "SPENTI"), 1000);
    }

    function updateUI() {
      document.getElementById('health').querySelector('.value').textContent = gameState.playerHealth;
      const totalPlayerAmmo = gameState.weapons.rifle.ammo + gameState.weapons.shotgun.ammo;
      const maxTotalPlayerAmmo = gameState.weapons.rifle.maxAmmo + gameState.weapons.shotgun.maxAmmo;
      document.getElementById('ammo').querySelector('.value').textContent = `${totalPlayerAmmo}/${maxTotalPlayerAmmo}`;

      document.getElementById('score').querySelector('.value').textContent = gameState.score;
      document.querySelector('.stat:nth-child(2) .value').textContent = gameState.level;

      healthBar.style.width = `${(gameState.playerHealth / gameState.maxHealth) * 100}%`;
      ammoBar.style.width = `${(totalPlayerAmmo / maxTotalPlayerAmmo) * 100}%`;

      const currentWeaponData = gameState.weapons[gameState.currentWeapon];
      weaponName.textContent = currentWeaponData.name;
      weaponAmmo.textContent = `${currentWeaponData.ammo}/${currentWeaponData.clipSize}`;

      updateZombieCounter();
      updateResourceDisplay();
    }

    function updateDeLoreanDashboardUI() {
        if (!gameState.inDeLorean) return;

        const currentDeLoreanWeaponData = gameState.deloreanWeapons[gameState.currentDeLoreanWeapon];

        dashSpeed.textContent = `${(Math.abs(gameState.deloreanPlayer.speed) * 300).toFixed(0)} km/h`;
        dashDistance.textContent = `${(gameState.deloreanDistanceTraveled * gameState.deloreanKmPerUnit).toFixed(2)} km`;
        dashFuel.textContent = `${gameState.deloreanFuel.toFixed(0)}%`;
        dashFuelBar.style.width = `${(gameState.deloreanFuel / gameState.maxDeLoreanFuel) * 100}%`;
        dashHeadlightsStatus.textContent = gameState.deloreanWeapons.machineGun.muzzleFlashLight ? "ACCESI" : "SPENTI"; // Reflects actual state
        dashWeaponName.textContent = currentDeLoreanWeaponData.name;
        dashWeaponAmmo.textContent = `${currentDeLoreanWeaponData.ammo}/${currentDeLoreanWeaponData.maxAmmo}`;
    }

    function updateZombieCounter() {
      zombieCount.textContent = gameState.zombies.length;
    }

    function showMessage(text, duration = 2000) {
      message.textContent = text;
      message.style.display = 'block';
      setTimeout(() => {
        message.style.display = 'none';
      }, duration);
    }

    function showHitEffect() {
      hitEffect.classList.remove('hit-animation');
      void hitEffect.offsetWidth;
      hitEffect.classList.add('hit-animation');
    }

    function shoot() {
      if (gameState.inDeLorean) return;

      const currentWeaponData = gameState.weapons[gameState.currentWeapon];
      const currentTime = performance.now();

      if (currentTime - currentWeaponData.lastShotTime < currentWeaponData.fireRate * 1000) {
          return;
      }

      if (currentWeaponData.ammo <= 0 || gameState.isReloading || currentWeaponData.isShooting) return;

      currentWeaponData.ammo--;
      updateUI();
      currentWeaponData.lastShotTime = currentTime;

      const actualDamage = gameState.isDamageBoostActive ? currentWeaponData.damage * gameState.damageBoostMultiplier : currentWeaponData.damage;
      const projectileSpeed = 50; // Example speed

      // Projectile direction based on camera (conceptual)
      // glMatrix.vec3.set: Imposta i componenti di un vettore 3D.
      glMatrix.vec3.set(tempVec3_1, // Usa tempVec3_1 pre-allocato per il vettore forward
          Math.cos(gameEngine.camera.yaw) * Math.cos(gameEngine.camera.pitch),
          Math.sin(gameEngine.camera.pitch),
          Math.sin(gameEngine.camera.yaw) * Math.cos(gameEngine.camera.pitch)
      );
      // glMatrix.vec3.normalize: Normalizza un vettore 3D.
      glMatrix.vec3.normalize(tempVec3_1, tempVec3_1);

      if (gameState.currentWeapon === 'rifle') {
          const newProjectile = physicsSystem.getProjectile(); // Get from pool
          newProjectile.x = playerPosition.x;
          newProjectile.y = playerPosition.y;
          newProjectile.z = playerPosition.z;
          newProjectile.dx = tempVec3_1[0];
          newProjectile.dy = tempVec3_1[1];
          newProjectile.dz = tempVec3_1[2];
          newProjectile.speed = projectileSpeed;
          newProjectile.damage = actualDamage;
          newProjectile.isCannonBall = false;
          newProjectile.isElectricityBall = false;
          newProjectile.active = true; // Ensure it's active
      } else if (gameState.currentWeapon === 'shotgun') {
          for (let i = 0; i < currentWeaponData.pellets; i++) {
              // Add spread to shotgun pellets
              const spreadX = (Math.random() - 0.5) * currentWeaponData.spreadAngle;
              const spreadY = (Math.random() - 0.5) * currentWeaponData.spreadAngle;
              // glMatrix.vec3.set: Imposta i componenti di un vettore 3D.
              glMatrix.vec3.set(tempVec3_2, // Usa tempVec3_2 pre-allocato per il vettore di spread
                  tempVec3_1[0] + spreadX,
                  tempVec3_1[1] + spreadY,
                  tempVec3_1[2]
              );
              // glMatrix.vec3.normalize: Normalizza un vettore 3D.
              glMatrix.vec3.normalize(tempVec3_2, tempVec3_2);

              const newProjectile = physicsSystem.getProjectile(); // Get from pool
              newProjectile.x = playerPosition.x;
              newProjectile.y = playerPosition.y;
              newProjectile.z = playerPosition.z;
              newProjectile.dx = tempVec3_2[0];
              newProjectile.dy = tempVec3_2[1];
              newProjectile.dz = tempVec3_2[2];
              newProjectile.speed = projectileSpeed;
              newProjectile.damage = actualDamage;
              newProjectile.isCannonBall = false;
              newProjectile.isElectricityBall = false;
              newProjectile.active = true; // Ensure it's active
          }
      }

      if (currentWeaponData.ammo === 0) {
        showMessage("RICARICA!", 1000);
        reload();
      }
    }

    function shootDeLoreanMachineGun() {
        if (!gameState.inDeLorean) return;

        const weaponData = gameState.deloreanWeapons.machineGun;
        const currentTime = performance.now();

        if (currentTime - weaponData.lastShotTime < weaponData.fireRate * 1000) {
            return;
        }

        if (weaponData.ammo <= 0 || weaponData.isShooting) {
            showMessage("MUNIZIONI MITRAGLIATRICE SCARICHE!", 1000);
            return;
        }

        weaponData.ammo--;
        updateDeLoreanDashboardUI();
        weaponData.lastShotTime = currentTime;

        const projectileSpeed = 70;
        // Direction based on DeLorean rotation
        const forwardX = Math.sin(gameState.deloreanPlayer.rotation);
        const forwardZ = -Math.cos(gameState.deloreanPlayer.rotation);

        for (let i = 0; i < 5; i++) {
            const newProjectile = physicsSystem.getProjectile(); // Get from pool
            newProjectile.x = deloreanPosition.x;
            newProjectile.y = deloreanPosition.y + 1.5;
            newProjectile.z = deloreanPosition.z;
            newProjectile.dx = forwardX + (Math.random() - 0.5) * 0.2;
            newProjectile.dy = (Math.random() - 0.5) * 0.2;
            newProjectile.dz = forwardZ + (Math.random() - 0.5) * 0.2;
            newProjectile.speed = projectileSpeed;
            newProjectile.damage = weaponData.damage;
            newProjectile.isCannonBall = false;
            newProjectile.isElectricityBall = false;
            newProjectile.active = true; // Ensure it's active
        }
    }

    function shootDeLoreanCannon() {
        if (!gameState.inDeLorean) return;

        const weaponData = gameState.deloreanWeapons.cannon;
        const currentTime = performance.now();

        if (currentTime - weaponData.lastShotTime < weaponData.fireRate * 1000) {
            return;
        }

        if (weaponData.ammo <= 0 || weaponData.isShooting) {
            showMessage("MUNIZIONI CANNONE SCARICHE!", 1000);
            return;
        }

        weaponData.ammo--;
        updateDeLoreanDashboardUI();
        weaponData.lastShotTime = currentTime;

        gameState.isDistorted = true;
        gameState.distortionTimer = 0.2;
        if (distortionOverlay) {
            distortionOverlay.style.display = 'block';
            distortionOverlay.classList.add('active');
        }

        const projectileSpeed = 40;
        // Direction based on DeLorean rotation
        const forwardX = Math.sin(gameState.deloreanPlayer.rotation);
        const forwardZ = -Math.cos(gameState.deloreanPlayer.rotation);

        const newProjectile = physicsSystem.getProjectile(); // Get from pool
        newProjectile.x = deloreanPosition.x;
        newProjectile.y = deloreanPosition.y + 1.5;
        newProjectile.z = deloreanPosition.z;
        newProjectile.dx = forwardX;
        newProjectile.dy = 0;
        newProjectile.dz = forwardZ;
        newProjectile.speed = projectileSpeed;
        newProjectile.damage = weaponData.damage;
        newProjectile.isCannonBall = true;
        newProjectile.isElectricityBall = false;
        newProjectile.active = true; // Ensure it's active
    }

    function rockHit(rock, damage) {
        rock.health -= damage;
        if (rock.health <= 0) {
            gameState.score += 20;
            gameState.destructibleRocks = gameState.destructibleRocks.filter(r => r !== rock);
            spawnRockReward(rock.position);
            updateAllInteractableMeshes();
        }
    }

    function spawnRockReward(position) {
        const random = Math.random();
        if (random < 0.2) {
            spawnPowerUp(position, 'health');
            showMessage("TROVATO: CAROTA DELLA SALUTE!", 1500);
        } else if (random < 0.4) {
            spawnPowerUp(position, 'ammo');
            showMessage("TROVATO: UOVO ENERGETICO!", 1500);
        } else if (random < 0.5) {
            spawnPowerUp(position, 'delorean_fuel');
            showMessage("TROVATO: BENZINA DELOREAN!", 1500);
        } else if (random < 0.7) {
            spawnPowerUp(position, 'speed_boost');
            showMessage("TROVATO: ZAMPA VELOCE!", 2000);
        } else if (random < 0.8) {
            gameState.resources += 5;
            showMessage("TROVATO: 5 RISORSE!", 1500);
            updateResourceDisplay();
        } else {
            const numZombies = Math.random() < 0.5 ? 1 : 2;
            createZombies(numZombies, false, position, true);
            showMessage(`ZOMBIE EMERSI! (${numZombies})`, 2000);
        }
    }

    function zombieHit(zombie, damage) {
        zombie.health -= damage;
        if (zombie.health <= 0) {
            gameState.score += (zombie.isLightningZombie ? 500 : 10 * gameState.level);
            if (zombie.isLightningZombie) {
                gameState.lightningZombieExists = false;
            }
            gameState.zombiesDestroyed++;
            updateUI();

            // Zombies are filtered out in physicsSystem.updateJSFallback
            // No need to filter here again, just mark as dead
            // The next physics update will remove them from gameState.zombies
            // For now, we'll keep the filter here for immediate removal
            gameState.zombies = gameState.zombies.filter(z => z !== zombie);
            updateAllInteractableMeshes();

            if (gameState.zombies.length === 0 && gameState.zombiesDestroyed >= gameState.zombiesTotal) {
                nextLevel();
            }
        }
    }

    function reload() {
      if (gameState.inDeLorean) return;

      const currentWeaponData = gameState.weapons[gameState.currentWeapon];
      if (gameState.isReloading || currentWeaponData.ammo === currentWeaponData.clipSize) return;

      gameState.isReloading = true;
      showMessage("RICARICA IN CORSO...", 2000);

      setTimeout(() => {
        currentWeaponData.ammo = currentWeaponData.clipSize;
        gameState.isReloading = false;
        updateUI();
        showMessage("PRONTO!", 1000);
      }, 2000);
    }

    function nextLevel() {
      gameState.level++;
      gameState.score += 100;
      gameState.zombiesTotal += 2;
      gameState.zombiesDestroyed = 0;

      gameState.weapons.rifle.ammo = gameState.weapons.rifle.clipSize;
      gameState.weapons.shotgun.ammo = gameState.weapons.shotgun.clipSize;

      gameState.playerHealth = gameState.maxHealth;

      showMessage(`LIVELLO ${gameState.level} INIZIO!`, 2500);
      updateUI();

      spawnPowerUp();

      setTimeout(() => {
        createZombies(gameState.zombiesTotal);
        createZombies(Math.floor(gameState.level / 2) + 1, false, null, false, true);
      }, 3000);
    }

    function checkPowerUpCollisions() {
      // Simplified collision check
      gameState.powerUps = gameState.powerUps.filter(powerUp => {
        if (powerUp.collected) return false;
        const distance = Math.sqrt(
            Math.pow(playerPosition.x - powerUp.position.x, 2) +
            Math.pow(playerPosition.z - powerUp.position.z, 2)
        );
        if (distance < 2) { // Simplified collision radius
          powerUp.collected = true;
          if (powerUp.type === 'health') {
            if (gameState.playerHealth < gameState.maxHealth) {
                gameState.playerHealth = Math.min(gameState.maxHealth, gameState.playerHealth + 15);
                showMessage("SALUTE +15", 1500);
            } else {
                gameState.score += 5;
                showMessage("SALUTE MASSIMA! +5 PUNTI", 1500);
            }
          } else if (powerUp.type === 'ammo') {
            const currentWeaponData = gameState.weapons[gameState.currentWeapon];
            if (currentWeaponData.ammo < currentWeaponData.maxAmmo) {
                currentWeaponData.ammo = Math.min(currentWeaponData.maxAmmo, currentWeaponData.ammo + 15);
                showMessage("MUNIZIONI +15", 1500);
            } else {
                gameState.score += 5;
                showMessage("MUNIZIONI MASSIME! +5 PUNTI", 1500);
            }
          } else if (powerUp.type === 'delorean_fuel') {
            if (gameState.inDeLorean) {
                gameState.deloreanFuel = Math.min(gameState.maxDeLoreanFuel, gameState.deloreanFuel + 70);
                gameState.deloreanPlayer.nitro = Math.min(100, gameState.deloreanPlayer.nitro + 50);
                showMessage("BENZINA +70% & NITRO!", 1500);
            } else {
                gameState.playerHealth = Math.max(0, gameState.playerHealth - 10);
                showHitEffect();
                createAtomicMushroom(playerPosition);
                showMessage("IL CARBURANTE È ESPLOSO!", 2000);
                if (gameState.playerHealth <= 0) {
                    gameOver();
                }
            }
          } else if (powerUp.type === 'damage_boost') {
            gameState.isDamageBoostActive = true;
            gameState.damageBoostTimer = gameState.damageBoostDuration;
            showMessage("DANNO AUMENTATO!", 2000);
          } else if (powerUp.type === 'speed_boost') {
            gameState.isSpeedBoostActive = true;
            gameState.speedBoostTimer = gameState.speedBoostDuration;
            showMessage("VELOCITÀ AUMENTATA!", 2000);
          }
          updateUI();
          updateDeLoreanDashboardUI();
          return false; // Remove collected power-up
        }
        return true; // Keep uncollected power-up
      });
    }

    function explodeFuelBarrel(position) {
        applyAOEDamage(position, gameState.deloreanWeapons.cannon.aoeRadius, 1000);
        createAtomicMushroom(position);
        showMessage("BARILE DI CARBURANTE ESPLOSO!", 1500);
    }

    function checkDeLoreanProximityAndEnter() {
        if (gameState.inDeLorean || gameState.gameOver) return;
        const distance = Math.sqrt(
            Math.pow(playerPosition.x - deloreanPosition.x, 2) +
            Math.pow(playerPosition.z - deloreanPosition.z, 2)
        );
        if (distance < 10) {
            enterDeLorean();
        }
    }

    function enterDeLorean() {
        if (gameState.inDeLorean) return;
        gameState.inDeLorean = true;
        // Conceptual: camera would now be relative to DeLorean
        updateUIVisibility();
        interactionPrompt.style.display = 'none';
        showMessage("ENTRATO NELLA DELOREAN!", 1500);
    }

    function exitDeLorean() {
        if (!gameState.inDeLorean) return;
        gameState.inDeLorean = false;
        // Conceptual: camera would return to player position
        updateUIVisibility();
        showMessage("USCITO DALLA DELOREAN!", 1500);
    }

    function resetGame() {
      gameState.playerHealth = 100;
      gameState.score = 0;
      gameState.level = 1;
      gameState.zombiesDestroyed = 0;
      gameState.zombiesTotal = 5;
      gameState.zombies = [];
      gameState.projectiles = []; // Reset projectiles pool
      gameState.powerUps = [];
      gameState.destructibleRocks = [];
      for (let i = 0; i < gameState.maxDestructibleRocks; i++) {
          createDestructibleRock();
      }

      gameState.isReloading = false;
      gameState.gameOver = false;
      gameState.nightVision = false;
      gameState.isShooting = false;
      gameState.lastShotPosition = { x: 0, y: 0, z: 0 };
      gameState.isDamageBoostActive = false;
      gameState.damageBoostTimer = 0;
      gameState.isDistorted = false;
      gameState.distortionTimer = 0;
      if (distortionOverlay) {
          distortionOverlay.style.display = 'none';
          distortionOverlay.classList.remove('active');
          distortionOverlay.style.filter = 'none';
      }

      gameState.isCloudStormActive = false;
      gameState.cloudStormTimer = 0;
      gameState.cloudStormLightningTimer = 0;

      gameState.isSpeedBoostActive = false;
      gameState.speedBoostTimer = 0;
      gameState.resources = 0;
      gameState.isCraftingMenuOpen = false;
      craftingMenu.style.display = 'none';

      gameState.gameDay = 1;
      gameState.lastWeatherChangeDay = 0;
      gameState.currentWeather = 'clear';
      gameState.weatherTimer = 0;
      gameState.lightningFlickerTimer = 0;
      gameState.isLightningActive = false;
      applyWeather('clear');

      gameState.lightningZombieExists = false;
      gameState.lightningStrikeRandomTimer = Math.random() * (gameState.lightningStrikeRandomIntervalMax - gameState.lightningStrikeRandomIntervalMin) + gameState.lightningStrikeRandomIntervalMin;
      gameState.weapons.rifle.ammo = gameState.weapons.rifle.clipSize;
      gameState.weapons.shotgun.ammo = gameState.weapons.shotgun.clipSize;
      gameState.currentWeapon = 'rifle';

      if (gameState.inDeLorean) {
          exitDeLorean();
      }
      deloreanPosition.x = -80;
      deloreanPosition.y = 2.5;
      deloreanPosition.z = 80;
      gameState.deloreanFuel = gameState.maxDeLoreanFuel;
      gameState.deloreanDistanceTraveled = 0;
      gameState.deloreanIsVulnerable = false;
      gameState.deloreanVulnerabilityTimer = 0;

      gameState.deloreanWeapons.machineGun.ammo = gameState.deloreanWeapons.machineGun.maxAmmo;
      gameState.deloreanWeapons.cannon.ammo = gameState.deloreanWeapons.cannon.maxAmmo;
      gameState.currentDeLoreanWeapon = 'machineGun';

      gameState.deloreanPlayer.speed = 0;
      gameState.deloreanPlayer.rotation = 0;
      gameState.deloreanPlayer.nitro = 100;
      gameState.deloreanPlayer.isDrifting = false;
      gameState.deloreanPlayer.driftTime = 0;

      playerPosition.x = 0;
      playerPosition.y = 1.6;
      playerPosition.z = 0;

      updateUI();
      updateDeLoreanDashboardUI();

      nightVisionOverlay.style.display = 'none';
      currentTime = 12;
      updateTimeOfDay(currentTime);

      crosshair.style.display = 'none';
      document.getElementById('uiContainer').style.display = 'none';
      document.querySelector('.zombie-counter').style.display = 'none';
      timeDisplayCard.style.display = 'none';
      weaponDisplay.style.display = 'none';
      deloreanDashboard.style.display = 'none';
      radarCanvas.style.display = 'none';
      resourceDisplay.style.display = 'none';
      objectiveDisplay.style.display = 'none';
      craftingMenu.style.display = 'none';

      interactionPrompt.style.display = 'none';

      nightVisionOverlay.style.display = 'none';
      if (distortionOverlay) {
          distortionOverlay.style.display = 'none';
          distortionOverlay.classList.remove('active');
          distortionOverlay.style.filter = 'none';
      }

      enterExitDeLoreanButton.style.display = 'none';
      headlightsButton.style.display = 'none';
deloreanMachineGunButton.style.display = 'none';
deloreanCannonButton.style.display = 'none';

      jumpButton.style.display = 'none';
      shootButton.style.display = 'none';
      reloadButton.style.display = 'none';
      nightVisionButton.style.display = 'none';
      switchWeaponButton.style.display = 'none';
      craftingButton.style.display = 'none';

      movement.joystickActive = false;
      joystickHandle.style.transform = 'translate(0, 0)';
      movement.forward = movement.backward = movement.left = movement.right = movement.sprint = false;
      joystickContainer.classList.remove('sprint-active');
    }

    // --- Stub/Placeholder functions for game logic ---
    function updateWeatherLogic(day) { console.log(`Weather logic updated for day ${day}`); }
    function triggerRandomLightning(delta) { console.log(`Lightning logic updated with delta ${delta}`); }
    function updateDeLoreanPhysics(delta) {
        // Simplified DeLorean physics
        gameState.deloreanPlayer.speed *= 0.98; // Apply drag
        if (keys[38]) gameState.deloreanPlayer.speed = Math.min(1.0, gameState.deloreanPlayer.speed + 0.01); // Up arrow
        if (keys[40]) gameState.deloreanPlayer.speed = Math.max(-0.5, gameState.deloreanPlayer.speed - 0.01); // Down arrow
        if (keys[37]) gameState.deloreanPlayer.rotation -= 0.03; // Left arrow
        if (keys[39]) gameState.deloreanPlayer.rotation += 0.03; // Right arrow

        gameState.deloreanDistanceTraveled += Math.abs(gameState.deloreanPlayer.speed) * delta;
        gameState.deloreanFuel = Math.max(0, gameState.deloreanFuel - Math.abs(gameState.deloreanPlayer.speed) * delta * 0.1); // Fuel consumption
    }
    function applyAOEDamage(position, radius, damage) { console.log(`AOE damage at ${position.x},${position.z} with radius ${radius} and damage ${damage}`); }
    function createAtomicMushroom(position) { console.log(`Atomic mushroom at ${position.x},${position.z}`); }
    function drawRadar() {
        if (!radarCtx) return;
        radarCtx.clearRect(0, 0, radarSize, radarSize);
        radarCtx.beginPath();
        radarCtx.arc(radarSize / 2, radarSize / 2, radarSize / 2 - 2, 0, Math.PI * 2);
        radarCtx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
        radarCtx.lineWidth = 2;
        radarCtx.stroke();

        // Player dot
        radarCtx.fillStyle = 'blue';
        radarCtx.beginPath();
        radarCtx.arc(radarSize / 2, radarSize / 2, 5, 0, Math.PI * 2);
        radarCtx.fill();

        // Zombies on radar (conceptual)
        gameState.zombies.forEach(z => {
            const relativeX = z.x - playerPosition.x;
            const relativeZ = z.z - playerPosition.z;
            const radarScale = radarSize / 100; // Map 100 game units to radar size

            const radarX = radarSize / 2 + relativeX * radarScale;
            const radarY = radarSize / 2 + relativeZ * radarScale;

            if (radarX > 0 && radarX < radarSize && radarY > 0 && radarY < radarSize) {
                radarCtx.fillStyle = 'red';
                radarCtx.beginPath();
                radarCtx.arc(radarX, radarY, 3, 0, Math.PI * 2);
                radarCtx.fill();
            }
        });
    }
    function updateObjective(delta) { console.log(`Objective updated with delta ${delta}`); }
    function clearObjective() { gameState.currentObjective = null; objectiveDisplay.style.display = 'none'; }
    function toggleCraftingMenu() {
        gameState.isCraftingMenuOpen = !gameState.isCraftingMenuOpen;
        craftingMenu.style.display = gameState.isCraftingMenuOpen ? 'flex' : 'none';
        updateUIVisibility(); // Adjust other UI based on menu state
    }
    function craftAmmo(weaponType) {
        const cost = weaponType === 'rifle' ? 5 : 8;
        const amount = weaponType === 'rifle' ? 30 : 8;
        if (gameState.resources >= cost) {
            gameState.resources -= cost;
            gameState.weapons[weaponType].ammo = Math.min(gameState.weapons[weaponType].maxAmmo, gameState.weapons[weaponType].ammo + amount);
            showMessage(`CRAFTED: ${amount} ${weaponType.toUpperCase()} AMMO!`, 1500);
            updateUI();
        } else {
            showMessage("NON ABBASTANZA RISORSE!", 1500);
        }
    }
    function updateResourceDisplay() {
        document.getElementById('resourceCount').textContent = gameState.resources;
    }
    function gameOver() {
        gameState.gameOver = true;
        document.getElementById('finalScore').textContent = `Punto Finale: ${gameState.score}`;
        gameOverScreen.style.display = 'flex';
        updateUIVisibility(); // Hide game UI
    }

    // Function to update UI visibility based on game state
    function updateUIVisibility() {
        const isGameActive = !gameState.gameOver && !gameState.isCraftingMenuOpen;
        const inDeLorean = gameState.inDeLorean;

        crosshair.style.display = isGameActive && !inDeLorean ? 'block' : 'none';
        document.getElementById('uiContainer').style.display = isGameActive && !inDeLorean ? 'flex' : 'none';
        document.querySelector('.zombie-counter').style.display = isGameActive ? 'block' : 'none';
        timeDisplayCard.style.display = isGameActive ? 'block' : 'none';
        weaponDisplay.style.display = isGameActive && !inDeLorean ? 'block' : 'none';
        deloreanDashboard.style.display = isGameActive && inDeLorean ? 'flex' : 'none';
        radarCanvas.style.display = isGameActive ? 'block' : 'none';
        resourceDisplay.style.display = isGameActive ? 'block' : 'none';
        objectiveDisplay.style.display = isGameActive && gameState.currentObjective ? 'block' : 'none';

        // Touch controls visibility
        const touchControls = document.getElementById('touchControls');
        if (isTouchDevice) {
            touchControls.style.display = 'block';
            joystickContainer.style.display = 'flex';
            jumpButton.style.display = inDeLorean ? 'none' : 'flex';
            shootButton.style.display = inDeLorean ? 'none' : 'flex';
            reloadButton.style.display = inDeLorean ? 'none' : 'flex';
            nightVisionButton.style.display = inDeLorean ? 'none' : 'flex';
            switchWeaponButton.style.display = inDeLorean ? 'none' : 'flex';
            craftingButton.style.display = inDeLorean ? 'none' : 'flex';

            enterExitDeLoreanButton.style.display = isGameActive && !inDeLorean && Math.sqrt(
                Math.pow(playerPosition.x - deloreanPosition.x, 2) +
                Math.pow(playerPosition.z - deloreanPosition.z, 2)
            ) < 10 ? 'flex' : 'none';

            headlightsButton.style.display = inDeLorean ? 'flex' : 'none';
            deloreanMachineGunButton.style.display = inDeLorean ? 'flex' : 'none';
            deloreanCannonButton.style.display = inDeLorean ? 'flex' : 'none';
        } else {
            touchControls.style.display = 'none';
        }
    }

    // Ensure initGame is called after the window has fully loaded
    window.onload = initGame;
  </script>
</body>
</html>

